#!/bin/bash

# <!-- IGNORE: This line is intentional DO NOT MODIFY --><pre><script>document.querySelector('body').firstChild.textContent = '#!/bin/bash'</script>

# "Get Fleek Network" is an attempt to make our software more accessible.
# By providing scripts to automate the installation process of our software,
# we believe that it can help improve the onboarding experience of our users.
#
# Quick install: `curl https://get.fleek.network | bash`
#
# This script automates the process illustrated in our guide "Running a Node in a Docker container"
# advanced users might find it better to follow the instructions in the guide
# If that's your preference, go ahead and check our guides https://docs.fleek.network
#
# For the users happy to have the script assist in the installation process of Fleek Network
# and the required dependencies, run the script at your own risk. Part of the project will
# verify if specific dependencies are installed or needed, but it won't try to customise or
# take into consideration your custom environment. If you have a custom environment, then
# is best to follow the instructions in our guide, as otherwise risk changing
# or overriding your custom setup.
#
# Ideally, the script will:
# - Check if the system has enough disk space and memory, otherwise warn the user
# - Verify if the user is in Docker, as Docker in Docker is not supported
# - Verify if Git is installed, if not install it
# - It'll do a quick health check to confirm Git is installed correctly 
# - Verify if Docker is installed, if not install it
# - It'll do a quick health check to confirm Docker is installed correctly
# - Request a pathname where to store the Ursa repository, otherwise providing a default,
#   e.g., `$HOME/fleek-network/ursa`
# - Pull the `ursa` project repository to the preferred target directory via HTTPS
#   instead of SSH for simplicity
# - Optionally, assist in setting up and securing domain name via SSL/TLS
# - Run the Docker stack
#¬†- Do a health check to confirm the Fleek Network Node is running
#
# Found an issue? Please report it here: https://github.com/fleek-network/get.fleek.network

# üöë Check if running in Bash and supported version
[ "$BASH" ] || { printf >&2 'üôè Run the script with Bash, please!\n'; exit 1; }
(( BASH_VERSINFO[0] > 4 || BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] >= 2 )) || { printf >&2 'üôè Bash 4.2 or newer is required!\n'; exit 1; }

# Date
dateRuntime=$(date '+%Y%m%d%H%M%S')

# Default
defaultGetFleekNetworkUrl="https://get.fleek.network"
defaultFleekNetworkWebsite="https://fleek.network"
defaultFleekNetworkDocsWebsite="https://docs.fleek.network"
defaultDiscordUrl="https://discord.gg/fleekxyz"
defaultFleekNetworkTwitterUrl="https://twitter.com/fleek_net"
defaultGetFleekNetworkRepository="https://github.com/fleek-network/get.fleek.network"
defaultUrsaHttpsRespository="https://github.com/fleek-network/ursa.git"
defaultUrsaPath="$HOME/fleek-network/ursa"
defaultUrsaNightlyImage="ghcr.io/fleek-network/ursa:nightly"
defaultDockerFullNodeRelativePath="./docker/full-node"
defaultDockerComposeYmlRelativePath="$defaultDockerFullNodeRelativePath/docker-compose.yml"
defaultMinMemoryBytesRequired=8000000
defaultMinDiskSpaceBytesRequired=10000000

# App state
userSelectedLanguage=""

# Localization
declare -a supportedLanguages=("en" "es" "pt" "ru" "vi" "jp" "ch" "ko")

for lang in "${supportedLanguages[@]}"; do
  # use of ?dateRuntime intentional, prevent cache, do not modify
  # TODO: disabled temporarily to test in branch `feat/localization`
  # . <(curl -s "$defaultGetFleekNetworkUrl/locales/$lang?$dateRuntime")
  . <(curl -s "https://raw.githubusercontent.com/fleek-network/get.fleek.network/feat/localization/locales/$lang?$dateRuntime")
done

# App text translations
declare -A transl=()

setLang() {
  declare -n _selectedLang="$1"
  for key in "${!_selectedLang[@]}"; do
    transl["$key"]=${_selectedLang[$key]}
  done
  
  userSelectedLanguage="$1"
}

# Set default locale
while true; do
  echo "üá¨üáß English"
  echo "üá™üá∏ Espa√±ol"
  echo "üáµüáπ Portugu√™s"
  echo "üá∑üá∫ P—É—Å—Å–∫–∏–π"
  echo "üáªüá≥ Ti·∫øng Vi·ªát"
  echo "üáØüáµ Êó•Êú¨Ë™û"
  echo "üá®üá≥ ‰∏≠Êñá"
  echo ""

  read -r -p "> " ans

  if [[ $ans == [eE]nglish ]]; then
    opt="en"
  elif [[ $ans == [eE]spa√±ol ]]; then
    opt="es"
  elif [[ $ans == [pP]ortugu√™s ]]; then
    opt="pt"
  elif [[ $ans == [pP]—É—Å—Å–∫–∏–π ]]; then
    opt="ru"
  elif [[ $ans =~ [tT]i·∫øng ]]; then
    opt="vi"
  elif [[ $ans =~ Êó•Êú¨Ë™û ]]; then
    opt="jp"
  elif [[ $ans =~ ‰∏≠Êñá ]]; then
    opt="ch"
  fi

  if [[ "${supportedLanguages[*]}" =~ $opt ]]; then
    setLang "$opt"

    break;
  fi
done

# Installer state
statusComplete="complete"
installationStatus=""

# Installer script dependencies
# e.g. jq as used to iterate the config
declare -a dependencies=("jq")

# Config (json)
config='{
  "dependencies": [
    {
      "name": "Yq - Cli YAML, JSON, XML, CSV",
      "bin": "yq",
      "pkgManager": {
        "arch": {
          "pkg": "go-yq",
          "name": "pacman"
        },
        "debian": {
          "pkg": "yq",
          "name": "snap"
        },
        "ubuntu": {
          "pkg": "yq",
          "name": "snap"
        }
      }
    },
    {
      "name": "Whois - Internet domain name and network number directory service",
      "bin": "whois",
      "pkgManager": {
        "arch": {
          "pkg": "whois",
          "name": "pacman"
        },
        "debian": {
          "pkg": "whois",
          "name": "apt-get"
        },
        "ubuntu": {
          "pkg": "whois",
          "name": "apt-get"
        }
      }
    },
    {
      "name": "tldextract-rs cli - extract tld info from url",
      "bin": "tldextract",
      "pkgManager": {
        "arch": {
          "pkg": "tldextract",
          "name": "pip"
        },
        "debian": {
          "pkg": "tldextract",
          "name": "apt-get"
        },
        "ubuntu": {
          "pkg": "tldextract",
          "name": "apt-get"
        }
      }
    },
    {
      "name": "dig - DNS lookup utility",
      "bin": "dig",
      "pkgManager": {
        "arch": {
          "pkg": "dnsutils",
          "name": "pacman"
        },
        "debian": {
          "pkg": "dnsutils",
          "name": "apt-get"
        },
        "ubuntu": {
          "pkg": "dnsutils",
          "name": "apt-get"
        }
      }
    }
  ]
}'

# Style utils
txtPrefixForBold=$(tput bold)
txtPrefixForNormal=$(tput sgr0)

mapLanguageYesNoQuitToSystem() {
  if [[ "$1" == "en_US" ]]; then
    echo "$2"

    return
  fi

  if [[ "$1" == "pt_PT" || "$1" == "es_ES" ]]; then
    case "${2}" in
      # sim / si
      [sS]*)    typed="y";;
      # nao / no
      [nN]*)    typed="n";;
      # abandonar
      [aA]*)    typed="q";;
      # sim / si
      [sS]*)    typed="y";;
      # saltar
      [sS][aA][lL][tT][aA][rR]*)  typed="skip";;
      *)        typed="INVALID"
    esac

    echo "$typed"

    return
  fi
}

# Confirm validators
confirmDomainName() {
  local validate="^([a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]\.)+[a-zA-Z]{2,}$"

  if whois "$1" | grep -Ei '[Uu]nallocated|returned 0 objects' > /dev/null; then
    return 1
  fi

  [[ $1 =~ $validate ]]
}

confirmIpAddress() {
  local validate="^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$"

  [[ "$1" =~ $validate ]] && ping -c1 -W1 "$1" > /dev/null
}

confirmEmailAddress() {
  local validate="^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]+$"

  [[ "$1" =~ $validate ]]
}

confirm() {
  intlAnswer=$(mapLanguageYesNoQuitToSystem "$1" "$2")

  case $intlAnswer in
    [yY])
      echo 0
      ;;
    [yY][eE][sS])
      echo 0
      ;;
    [nN])
      echo 1
      ;;
    [nN][oO])
      echo 1
      ;;
  esac;
}

resetStyles() {
  echo "${txtPrefixForNormal}"
}

exitInstaller() {
  resetStyles
  exit 1;
}

hasCommand() {
  command -v "$1" >/dev/null 2>&1
}

clearScr() {
  printf '\e[H\e[2J'
}

launchAsciiArt() {
  printf "\r\n"

  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ"
  echo
  echo "‚ö°Ô∏è ${transl[ascii_art_fleek_team_presents]} ‚ö°Ô∏è"
  echo

# the cat and ascii art (ART, as `here tag``)
# is intentionally positioned to the most left
#¬†do not change
cat << "ART"
        _..._
      .'     '.     _
    /    .-""-\   _/ \
  .-|   /:.   |  |   |
  |  \  |:.   /.-'-./
  | .-'-;:__.'    =/
  .'=  *=|URSA _.='
  /   _.  |    ;
  ;-.-'|    \   |
/   | \    _\  _\
\__/'._;.  ==' ==\
        \    \   |
        /    /   /
        /-._/-._/
        \   `\  \
          `-._/._/
ART
# üëÜ ART (here tag) end positioned to the most left intentionally

  echo
  echo "‚≠êÔ∏è Ursa, a Decentralized Content Delivery Network (DCDN) ‚≠êÔ∏è"
  echo
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ üåç ${txtPrefixForBold}Website ${txtPrefixForNormal}https://fleek.network"
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ üìö ${txtPrefixForBold}Documentation ${txtPrefixForNormal}https://docs.fleek.network"
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ üíæ ${txtPrefixForBold}Git repository ${txtPrefixForNormal}https://github.com/fleek-network/ursa"
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ ü§ñ ${txtPrefixForBold}Discord ${txtPrefixForNormal}https://discord.gg/fleekxyz"
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ üê§ ${txtPrefixForBold}Twitter ${txtPrefixForNormal}https://twitter.com/fleek_net"
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ üé® ${txtPrefixForBold}Ascii art by ${txtPrefixForNormal}https://www.asciiart.eu"
}


asciiArtNoOSSupport() {
# the cat and ascii art (ART, as `here tag``)
# is intentionally positioned to the most left
#¬†do not change
cat << "ART"
.     .       .  .   . .   .   . .    +  .
  .     .  :     .    .. :. .___---------___.
       .  .   .    .  :.:. _".^ .^ ^.  '.. :"-_. .
    .  :       .  .  .:../:            . .^  :.:\.
        .   . :: +. :.:/: .   .    .        . . .:\
 .  :    .     . _ :::/:               .  ^ .  . .:\
  .. . .   . - : :.:./.                        .  .:\
  .      .     . :..|:                    .  .  ^. .:|
    .       . : : ..||        .                . . !:|
  .     . . . ::. ::\(                           . :)/
 .   .     : . : .:.|. ######              .#######::|
  :.. .  :-  : .:  ::|.#######           ..########:|
 .  .  .  ..  .  .. :\ ########          :######## :/
  .        .+ :: : -.:\ ########       . ########.:/
    .  .+   . . . . :.:\. #######       #######..:/
      :: . . . . ::.:..:.\           .   .   ..:/
   .   .   .  .. :  -::::.\.       | |     . .:/
      .  :  .  .  .-:.":.::.\             ..:/
 .      -.   . . . .: .:::.:.\.           .:/
.   .   .  :      : ....::_:..:\   ___.  :/
   .   .  .   .:. .. .  .: :.:.:\       :/
     +   .   .   : . ::. :.:. .:.|\  .:/|
     .         +   .  .  ...:: ..|  --.:|
.      . . .   .  .  . ... :..:.."(  ..)"
 .   .       .      :  .   .: ::/  .  .::\
ART
# üëÜ ART (here tag) end positioned to the most left intentionally

  echo
  echo "üëæ ${transl[ascii_art_no_os_support_alien_technosignature]} üëæ"
  echo

  sleep 3
}

requestAuthorizationAndExec() {
  printf -v prompt "\nü§ñ %s (y/n)?" "$1"
  read -r -p "$prompt"$'\n> ' answer

  intlAnswer=$(mapLanguageYesNoQuitToSystem "$userSelectedLanguage" "$answer")

  if [[ "$intlAnswer" == [nN] || "$intlAnswer" == [nN][oO] ]]; then
    printf "\n\n"

    showErrorMessage "$2"

    exitInstaller
  fi

  printf "\n\n"

  $3
}

onExitInstallerTodos() {
  resetStyles
}

onInterruption() {
  # Only show warning message if install NOT complete
  if [[ "$installationStatus" != "$statusComplete" ]]; then
    printf "\r\n"
    echo "üò¨ ${transl[on_interruption_ouch_error]}"
    echo
    printf "%s" "${transl[on_interruption_if_require_support]}" | sed "s/_defaultDiscordUrl_/\"${defaultDiscordUrl}\"/g"

    onExitInstallerTodos
    exit 1
  fi

  onExitInstallerTodos
  exit 0
}

toLowerCase() {
  echo "$1" | tr '[:upper:]' '[:lower:]'
}

showOkMessage() {
  printf "\r\n‚úÖ %s\n" "$1"  
}

showErrorMessage() {
  printf "\r\nüö© %s\n" "$1" >&2
}

showPoopMessage() {
  printf "\r\nüí© %s\n" "$1" >&2
}

showHintMessage() {
  printf "\r\nüí° %s\n" "$1"  
}

showDisclaimer() {
  # Display artwork
  launchAsciiArt

  printf "\r\n\n"
  echo "‚≠êÔ∏è ${transl[show_disclaimer_title]}"
  echo
  echo "${transl[show_disclaimer_if_happy]}"
  echo
  printf "%s üëÄ." "${transl[show_disclaimer_script_repository]}" | sed "s/_defaultGetFleekNetworkRepository_/\"${defaultGetFleekNetworkRepository}\"/g"
  echo
  echo "ü§ì ${transl[show_disclaimer_more]}"
  printf "%s" \
    "$(printf "%s" "${transl[show_disclaimer_guides]}" | sed "s/_defaultFleekNetworkDocsWebsite_/\"${defaultFleekNetworkDocsWebsite}\"/g; s/_defaultGetFleekNetworkRepository_/${defaultGetFleekNetworkRepository}/g")"

  printf -v prompt "\n\nü§ñ %s?\n%s" \
    "$(printf "%s" "${transl[show_disclaimer_should_continue]}" | sed "s/_yes_/\"${transl[common_prompt_yes_as_y]}\"/g; s/_no_/\"${transl[common_prompt_no_as_n]}\"/g")" \
    "$(printf "%s" "${transl[show_disclaimer_should_yes_or_no_quit]}" | sed "s/_yes_/\"${transl[common_prompt_yes_as_y]}\"/g; s/_no_/\"${transl[common_prompt_no_as_n]}\"/g")"
  while read -rp "$prompt"$'\n> ' ans; do
    data=$(confirm "$userSelectedLanguage" "$ans")

    [[ ! $data ]] && continue

    if [[ "$data" -eq 1 ]]; then
      echo
      echo "ü¶ñ ${transl[show_disclaimer_terminates_here]}"
      echo
      printf "%s" \
        "$(printf "%s" "${transl[show_disclaimer_terminates_otherwise]}" | sed "s/_defaultFleekNetworkWebsite_/\"${defaultFleekNetworkWebsite}\"/g")"    
      echo

      exitInstaller
    elif [[ "$data" -eq 0 ]]; then
      break
    fi
  done
}

commonWarningMessage() {
  echo "${transl[common_warning_msg_try_support]}"
  printf "%s" \
    "$(printf "%s" "${transl[common_warning_msg_information_declassified]}" | sed "s/_defaultFleekNetworkTwitterUrl_/\"${defaultFleekNetworkTwitterUrl}\"/g")"    
  echo
  echo "${transl[common_warning_msg_check_guides]}"
  echo
  printf "%s" \
    "$(printf "%s" "${transl[common_warning_msg_visit_docs]}" | sed "s/_defaultFleekNetworkDocsWebsite_/\"${defaultFleekNetworkDocsWebsite}\"/g")"    
}

windowsUsersWarning() {
  asciiArtNoOSSupport
  echo "‚ö†Ô∏è ${transl[windows_users_warning_not_supported]}"
  echo "${transl[windows_users_warning_if_not_enable_wsl]}"
  echo
  commonWarningMessage
}

macOsUsersWarning() {
  asciiArtNoOSSupport
  echo "‚ö†Ô∏è ${transl[macos_users_warning_not_supported]}"
  echo
  echo "${transl[macos_users_warning_has_discontinued]}"
  echo
  commonWarningMessage
}

getJQPropertyValue() {
  echo "${1}" | base64 --decode | jq -r "${2}"
}

installGit() {
  os=$(identifyOS)

  if [[ "$os" == "linux" ]]; then
    distro=$(identifyDistro)

    if [[ "$distro" == "ubuntu" ]] || [[ "$distro" == "debian" ]]; then
      sudo apt-get install git
    elif [[ "$distro" =~ "arch"  ]]; then
      sudo pacman -Syu git
    else
      showErrorMessage \
        "$(printf "%s" "${transl[install_git_oops_os_and_distro]}" | sed "s/_os_/\"${os}\"/g; s/_distro_/\"${distro}\"/g; s/_defaultFleekNetworkDocsWebsite_/${defaultFleekNetworkDocsWebsite}/g")"

      exitInstaller
    fi
  else
    showErrorMessage \
      "$(printf "%s" "${transl[install_git_oops_os]}" | sed "s/_os_/\"${os}\"/g; s/_defaultFleekNetworkDocsWebsite_/${defaultFleekNetworkDocsWebsite}/g")"

    exitInstaller
  fi
}

identifyOS() {
  unameOut="$(uname -s)"

  case "${unameOut}" in
      Linux*)     os=Linux;;
      Darwin*)    os=Mac;;
      CYGWIN*)    os=Cygwin;;
      MINGW*)     os=MinGw;;
      *)          os="UNKNOWN:${unameOut}"
  esac

  osToLc=$(toLowerCase "$os")

  echo "$osToLc"
}

isOSSupported() {
  if [[ "$1" == "cygwin" ]] || [[ "$1" == "mingw" ]]; then
    printf "\n"

    windowsUsersWarning

    exitInstaller
  fi

  if [[ "$1" == "mac" ]]; then
    printf "\n"

    macOsUsersWarning

    exitInstaller
  fi

  if [[ "$1" == "ubuntu" ]]; then
    currVersion=$(lsb_release -r -s | tr -d '.')

    if [[ "$currVersion" -lt "2204" ]]; then
      echo
      echo "üëπ ${transl[is_os_supported_oops_need_ubuntu]}"
      echo

      exitInstaller
    fi
  fi

  if [[ "$1" == "debian" ]]; then
    currVersion=$(lsb_release -r -s | tr -d '.')

    if [[ "$currVersion" -lt "11" ]]; then
      echo
      echo "üëπ ${transl[is_os_supported_oops_need_debian]}"
      echo

      exitInstaller
    fi
  fi
}

identifyDistro() {
  if [[ -f /etc/os-release ]]; then
    source /etc/os-release
    echo "$ID"

    exit 0
  fi
  
  uname
}

checkSystemHasRecommendedResources() {
  mem=$(awk '/^MemTotal:/{print $2}' /proc/meminfo);
  partDiskSpace=$(df --output=avail -B 1 "$PWD" |tail -n 1)

  if [[ ("$mem" -lt "$defaultMinMemoryBytesRequired") ]] || [[ ( "$partDiskSpace" -lt "$defaultMinDiskSpaceBytesRequired" ) ]]; then
    echo "üò¨ ${transl[check_sys_has_recommended_resources_oh_no_need_at_least]}"
    echo
    printf -v prompt "\n\nü§ñ %s?" \
      "$(printf "%s" "${transl[common_prompt_are_you_sure_continue_y_or_n]}" | sed "s/_yes_/\"${transl[common_prompt_yes_as_y]}\"/g; s/_no_/\"${transl[common_prompt_no_as_n]}\"/g")"
    read -r -p "$prompt"$'\n> ' answer

    intlAnswer=$(mapLanguageYesNoQuitToSystem "$userSelectedLanguage" "$answer")

    if [[ "$intlAnswer" == [nN] || "$intlAnswer" == [nN][oO] ]]; then
      exitInstaller
    fi

    echo "üòÖ ${transl[check_sys_has_recommended_resources_warning_below_recommendation]}"

    sleep 5

    return 0
  fi
  
  showOkMessage "${transl[check_sys_has_recommended_resources_great_enought_resources]}"
}

checkIfGitInstalled() {
  if ! hasCommand git; then
    echo "üòÖ ${transl[check_if_git_installed_oops]}"
    echo

    requestAuthorizationAndExec \
      "${transl[common_check_installed_we_can_start_install]}" \
      "${transl[check_if_git_installed_need_git_installed]}" \
      installGit

    if [[ "$?" = 1 ]]; then
      showErrorMessage "${transl[check_if_git_installed_oops_failed_install]}"

      exitInstaller
    fi
  fi

  showOkMessage "${transl[check_if_git_installed_success_install]}"
}

gitHealthCheck() {
  if ! hasCommand git; then
    showErrorMessage "${transl[git_health_check_oops_odd_reason]}"

    exitInstaller
  fi
}

installDocker() {
  os=$(identifyOS)

  if [[ "$os" == "linux" ]]; then
    distro=$(identifyDistro)

    if [[ "$distro" == "ubuntu" ]]; then
      sudo apt-get update
      sudo apt-get install \
        ca-certificates \
        curl \
        gnupg \
        lsb-release

      sudo mkdir -p /etc/apt/keyrings
      curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

      echo \
        "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
        $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

      sudo apt-get update

      sudo apt-get install \
          docker-ce \
          docker-ce-cli \
          containerd.io \
          docker-compose-plugin \
          docker-compose

      # https://docs.docker.com/build/buildkit/
      sudo mkdir -p /etc/docker
      sudo bash -c 'echo "{
        \"features\": {
          \"buildkit\" : true
          }
        }" > /etc/docker/daemon.json'
    elif [[ "$distro" == "debian" ]]; then
      sudo apt-get update
      sudo apt-get install \
        ca-certificates \
        curl \
        gnupg \
        lsb-release \
        dnsutils

      sudo mkdir -p /etc/apt/keyrings
      curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

      echo \
        "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \
        $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

      sudo apt-get update

      sudo apt-get install \
          docker-ce \
          docker-ce-cli \
          containerd.io \
          docker-compose-plugin \
          docker-compose

      # https://docs.docker.com/build/buildkit/
      sudo mkdir -p /etc/docker
      sudo bash -c 'echo "{
        \"features\": {
          \"buildkit\" : true
          }
        }" > /etc/docker/daemon.json'
    elif [[ "$distro" =~ "arch" ]]; then
      sudo pacman -Syu gnome-terminal docker docker-compose

      sudo systemctl enable docker.service

      latestKernel=$(pacman -Q linux)
      currentKernel=$(uname -r)

      if [[ "$latestKernel" != "$currentKernel" ]]; then
        echo "‚úã ${transl[install_docker_need_reboot]}"
        printf "%s" "${transl[install_docker_need_reboot_reason]}" | sed "s/_currentKernel_/\"${currentKernel}\"/g; s/_latestKernel_/${latestKernel}/g"
        echo
        echo "${transl[install_docker_need_reboot_if_failure]}"
        echo "${transl[install_docker_suggest_rebooting]}"
        echo

        read -rp "${transl[common_press_enter_continue]} "
      fi
    else
      printf -v common_oops_linux_distro_not_supported "%s" \
      "$(printf "%s" "${transl[common_oops_linux_distro_not_supported]}" | sed "s/_defaultGetFleekNetworkUrl_/\"${defaultGetFleekNetworkUrl}\"/g; s/_defaultFleekNetworkDocsWebsite_/${defaultFleekNetworkDocsWebsite}/g")"
      showErrorMessage "${common_oops_linux_distro_not_supported}"

      exitInstaller
    fi
  else
    printf -v common_oops_os_not_supported "%s" \
    "$(printf "%s" "${transl[common_oops_os_not_supported]}" | sed "s/_defaultFleekNetworkDocsWebsite_/\"${defaultFleekNetworkDocsWebsite}\"/g")"
    showErrorMessage "${common_oops_os_not_supported}"

    exitInstaller
  fi
}

checkIfDockerInstalled() {
  # TODO: docker-compose is going to be deprecated
  #¬†but before moving to `docker compose` as subcommand
  # is required to check the user docker version and also
  # check if docker compose is available. Some users are still
  # using legacy e.g., preinstalled docker or archlinux, etc
  if ! hasCommand docker || ! hasCommand docker-compose; then
    printf "üòÖ %s\n" "${transl[check_if_docker_installed]}"

    requestAuthorizationAndExec \
      "${transl[common_check_installed_we_can_start_install]}" \
      "${transl[check_if_docker_need_docker_installed]}" \
      installDocker

    if [[ "$?" = 1 ]]; then
      showErrorMessage "${transl[check_if_docker_oops_failed_install_docker]}"

      exitInstaller
    fi
  fi

  showOkMessage "${transl[check_if_docker_success]}"
}

dockerHealthCheck() {
  if ! hasCommand docker-compose; then
    showErrorMessage "${transl[docker_health_check_oops_docker_compose]}"

    exitInstaller
  fi

  expectedMessage="Hello from Docker"
  res=$(docker run -i --log-driver=none -a stdout hello-world)

  if ! echo "$res" | grep "$expectedMessage" &> /dev/null; then
    showErrorMessage "${transl[docker_health_check_oops_docker_daemon_hello_world]}"

    exitInstaller
  fi

  showOkMessage "${transl[docker_health_check_passed]}"
}

requestPathnameForUrsaRepository() {
  # TODO: on translation, the selected path needs to be computed
  # that is that on runtime the defaultPath might need to be replaced
  # by the user selected choice, as we have these as precomputed text
  # TODO: close after test param expansion, see below
  selectedPath=$defaultUrsaPath

  printf -v prompt "\nü§ñ %s\n\n%s?\n%s" \
    "${transl[request_path_for_ursa_repo_save_to_location_use_default]/_selectedPath_/$selectedPath}" \
    "$(printf "%s" "${transl[request_path_for_ursa_repo_save_to_location_y_or_n_change]}" | sed "s/_yes_/\"${transl[common_prompt_yes_as_y]}\"/g; s/_no_/\"${transl[common_prompt_no_as_n]}\"/g")" \
    "${transl[request_path_for_ursa_repo_save_to_location_happy_proceed]}" \
    "$(printf "%s" "${transl[request_path_for_ursa_repo_save_to_location_y_or_n_change]}" | sed "s/_yes_/\"${transl[common_prompt_yes_as_y]}\"/g; s/_no_/\"${transl[common_prompt_no_as_n]}\"/g")"
  read -r -p "$prompt"$'\n> ' answer

  intlAnswer=$(mapLanguageYesNoQuitToSystem "$userSelectedLanguage" "$answer")

  if [[ ! "$intlAnswer" == "" && "$intlAnswer" == [nN] || "$intlAnswer" == [nN][oO] ]]; then
    printf -v prompt "\nüôã‚Äç‚ôÄÔ∏è %s" "${transl[request_path_for_ursa_repo_save_to_locattion_where_store]}"
    read -r -p "$prompt"$'\n> ' answer
  
    selectedPath="$answer"
  fi


  if [[ -d "$selectedPath" ]]; then
    # TODO: test param expansion
    showErrorMessage "${transl[request_path_for_ursa_repo_save_to_locattion_oops_already_exists]/_selectedPath_/$selectedPath}"

    read -r -p "${transl[common_press_enter_retry]}..."

    requestPathnameForUrsaRepository
  fi

  if ! mkdir -p "$selectedPath"; then
    # TODO: test param expansion
    showErrorMessage "${transl[request_path_for_ursa_repo_save_to_oops_failed_create_dir]/_selectedPath_/$selectedPath}"

    exitInstaller
  fi

  echo "$selectedPath"
}

cloneUrsaRepositoryToPath() {
  if ! git clone $defaultUrsaHttpsRespository "$1"; then
    showErrorMessage \
      "$(printf "%s" "${transl[clone_ursa_repo_to_path_oops_failed_to_clone]}" | sed "s/_defaultUrsaHttpsRespository_/\"${defaultUrsaHttpsRespository}\"/g")"

    exitInstaller
  fi

  showOkMessage \
    "$(printf "%s" "${transl[clone_ursa_repo_to_path_ok_msg]}" | sed "s/_defaultUrsaHttpsRespository_/\"${defaultUrsaHttpsRespository}\"/g; s/_ursaPath_/${1}/g")"

  printf "\r\n"
}

restartDockerStack() {
  echo "ü§ñ ${transl[restart_docker_stack_is_going_to_restart]}"
  echo

  # TODO: Use health check instead
  sleep 10
  sudo docker-compose -f "$defaultDockerComposeYmlRelativePath" stop

  showOkMessage "${transl[restart_docker_stack_is_going_to_start]}"

  # TODO: Use health check instead
  sleep 10
  sudo docker-compose -f "$defaultDockerComposeYmlRelativePath" up -d

  showOkMessage "${transl[restart_docker_stack_has_restarted]}"

  sleep 3
}

showDockerStackLog() {
  echo
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ"
  echo
  echo "ü•≥ ${transl[show_docker_stack_log_great]}"
  echo
  echo "${transl[show_docker_stack_log_stack_should_be_running]}"
  echo
  echo "${transl[show_docker_stack_log_stack_logs_can_be_verbose_1_of_2]}"
  echo "${transl[show_docker_stack_log_stack_logs_can_be_verbose_2_of_2]}"
  echo "https://docs.fleek.network/guides/Network%20nodes/fleek-network-node-health-check-guide"
  echo
  echo "${transl[show_docker_stack_log_stack_logs_handy_commands]}"
  echo
  echo "  - ${transl[show_docker_stack_log_stack_logs_handy_cmd_show_logs]}:"
  echo
  echo "    ${txtPrefixForBold}docker-compose -f ./docker/full-node/docker-compose.yml logs -f${txtPrefixForNormal}"
  echo
  echo "  - ${transl[show_docker_stack_log_stack_logs_handy_cmd_signit]}:"
  echo
  echo "    ${txtPrefixForBold}Ctrl-c${txtPrefixForNormal}"
  echo
  echo "${transl[show_docker_stack_log_stack_logs_can_stop_start_docker]}"
  echo "${transl[show_docker_stack_log_stack_logs_can_stop_start_docker_example]}"
  echo
  echo "${transl[show_docker_stack_log_stack_logs_can_stop_then_after_start_or_stop]}"
  echo
  echo "  - ${transl[show_docker_stack_log_stack_logs_can_stop_then_after_start]}"
  echo
  echo "    ${txtPrefixForBold}docker-compose -f ./docker/full-node/docker-compose.yml up${txtPrefixForNormal}"
  echo
  echo "  - ${transl[show_docker_stack_log_stack_logs_can_stop_then_after_stop]}"
  echo
  echo "    ${txtPrefixForBold}docker-compose -f ./docker/full-node/docker-compose.yml down${txtPrefixForNormal}"
  echo
  echo "ü•π ${transl[show_docker_stack_log_stack_logs_seems_a_lot]}"
  # The extra white space between ‚úèÔ∏è and start of text is intentional and used for alignment
  printf "ü§ì  %s" "${transl[show_docker_stack_log_stack_logs_learn_how_maintain]}" | sed "s/_defaultFleekNetworkDocsWebsite_/\"${defaultFleekNetworkDocsWebsite}\"/g"

  printf "üåà %s" "${transl[show_docker_stack_log_stack_logs_got_feedback]}" | sed "s/_defaultDiscordUrl_/\"${defaultDiscordUrl}\"/g; s/_defaultFleekNetworkTwitterUrl_/${defaultFleekNetworkTwitterUrl}/g"
  echo
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ"
  echo

  printf -v prompt "\nüôã‚Äç‚ôÄÔ∏è %s\n%s" "${transl[show_docker_stack_log_stack_logs_prompt_see_output]}" "${transl[show_docker_stack_log_stack_logs_prompt_see_output_y_or_skip]}"
  read -r -p "$prompt"$'\n> ' answer

  intlAnswer=$(mapLanguageYesNoQuitToSystem "$userSelectedLanguage" "$answer")

  if [[ "$intlAnswer" == [sS][kK][iI][pP] ]]; then
    printf "\r\n"

    echo "üöÄ ${transl[show_docker_stack_log_stack_logs_completed_process_thanks]}"
    printf "ü§ó %s" "${transl[show_docker_stack_log_stack_logs_completed_process_remember]}" | sed "s/_defaultFleekNetworkWebsite_/\"${defaultFleekNetworkWebsite}\"/g"

    echo

    onExitInstallerTodos
    
    exit 0;
  fi

  # whitespace to improve   
  printf "\r\n"
  
  echo "üëã ${transl[show_docker_stack_log_stack_logs_quick_hint]}!"
  echo
  echo "${transl[show_docker_stack_log_stack_logs_stack_logs_verbose]}"
  echo
  echo "${transl[show_docker_stack_log_stack_logs_stack_keeps_awake_discord]}"
  echo
  echo "${transl[show_docker_stack_log_stack_logs_about_log_messages_ignore]}"

  read -r -p "${transl[common_press_enter_continue]}... "

  sudo docker-compose -f "$defaultDockerComposeYmlRelativePath" logs -f
}

initLetsEncrypt() {
  email="$1"
  domain="$2"

  if [[ -z "$1" || -z "$2" ]]; then
    showErrorMessage "${transl[init_lets_encrypt_gosh_embarrassing_missing_args]} üôè"

    exitInstaller
  fi

  rsa_key_size=4096
  base_path=./docker/full-node
  config_path="$defaultDockerComposeYmlRelativePath"
  data_path="$defaultDockerFullNodeRelativePath/data/certbot"
  staging=0

  # TODO: Move this checkup much earlier, in the init of installer
  # Do we have the required files, if not interrupt the process?
  if [[ ! -d "$base_path" || ! "$(ls -A $base_path)" ]]; then
    showErrorMessage "${transl[init_lets_encrypt_oops_missing_required_files]} üôè"

    exitInstaller
  fi

  if [[ ! -e "$data_path/conf/options-ssl-nginx.conf" || ! -e "$data_path/conf/ssl-dhparams.pem" ]]; then
    echo
    echo "ü§ñ ${transl[init_lets_encrypt_download_recommended_tls]}..."
    echo

    mkdir -p "$data_path/conf"

    curl -s https://raw.githubusercontent.com/certbot/certbot/master/certbot-nginx/certbot_nginx/_internal/tls_configs/options-ssl-nginx.conf > "$data_path/conf/options-ssl-nginx.conf"
    curl -s https://raw.githubusercontent.com/certbot/certbot/master/certbot/certbot/ssl-dhparams.pem > "$data_path/conf/ssl-dhparams.pem"
    echo
  fi

  echo
  echo "ü§ñ ${transl[init_lets_encrypt_create_dummy_certificates]/_domain_/$domain} üôè"
  echo

  path="/etc/letsencrypt/live/$domain"
  mkdir -p "$data_path/conf/live/$domain"

  if ! docker-compose -f "$config_path" \
    run --rm --entrypoint "\
    openssl req -x509 -nodes -newkey rsa:$rsa_key_size -days 1\
      -keyout '$path/privkey.pem' \
      -out '$path/fullchain.pem' \
      -subj '/CN=localhost'" certbot; then    
    showErrorMessage "${transl[init_lets_encrypt_oops_failed_create_dummy_certificate]}"

    exitInstaller
  fi

  echo
  echo "ü§ñ ${transl[init_lets_encrypt_starting_nginx]} üôè"
  echo

  if ! docker-compose -f "$config_path" up --force-recreate -d nginx; then
    showErrorMessage "${transl[init_lets_encrypt_failed_start_nginx]}..."

    exitInstaller
  fi
  
  echo
  echo "ü§ñ ${transl[init_lets_encrypt_deleting_dummy_certificate]}..."
  echo

  if ! docker-compose -f "$config_path" \
    run --rm --entrypoint "\
    rm -Rf /etc/letsencrypt/live/$domain && \
    rm -Rf /etc/letsencrypt/archive/$domain && \
    rm -Rf /etc/letsencrypt/renewal/$domain.conf" certbot; then

    showErrorMessage "${transl[init_lets_encrypt_oops_failed_delete_certificates]/_domain_/$domain}..."

    exitInstaller
  fi

  echo
  echo "ü§ñ ${transl[init_lets_encrypt_requesting_lets_encrypt_certificates]/_domain_/$domain}..."
  echo

  # Enable staging mode if needed
  if [ $staging != "0" ]; then staging_arg="--staging"; fi

  if ! docker-compose -f "$config_path" run --rm --entrypoint "\
    certbot certonly --webroot -w /var/www/certbot \
      $staging_arg \
      --email $email \
      --domain $domain \
      --rsa-key-size $rsa_key_size \
      --agree-tos -n \
      --force-renewal" certbot; then
    showErrorMessage "${transl[init_lets_encrypt_oops_failed_create_tls_certificates]} https://docs.fleek.network/guides/Network%20nodes/fleek-network-securing-a-node-with-ssl-tls"

    printf -v prompt "\nüí° %s\n\nüôã‚Äç‚ôÄÔ∏è %s\n%s" "${transl[init_lets_encrypt_prompt_recommend_try_again]}" "${transl[init_lets_encrypt_prompt_recommend_try_again_ask]}" "${transl[init_lets_encrypt_prompt_recommend_try_again_y_or_quit]}"
    read -r -p "$prompt"$'\n> ' answer

    intlAnswer=$(mapLanguageYesNoQuitToSystem "$userSelectedLanguage" "$answer")

    if [[ "$intlAnswer" == [qQ] ]]; then
      printf "ü¶ñ %s" "${transl[init_lets_encrypt_prompt_recommend_you_have_quit]}" | sed "s/_defaultFleekNetworkDocsWebsite_/\"${defaultFleekNetworkDocsWebsite}\"/g"

      exit 1
    fi

    if [[ "$intlAnswer" == "" || "$intlAnswer" == [yY] || "$intlAnswer" == [yY][eE][sS] ]]; then    
      echo
      echo "üí° ${transl[init_lets_encrypt_if_issue_persists]}"
      echo "${transl[init_lets_encrypt_linux_os_dns_config_location_1_of_2]}"
      echo "${transl[init_lets_encrypt_linux_os_dns_config_location_2_of_2]}"
      echo
      echo "ü§ñ ${transl[init_lets_encrypt_restart_docker_stack]}..."
      echo
      sudo docker-compose -f "$defaultDockerComposeYmlRelativePath" down      
      sudo docker-compose -f "$defaultDockerComposeYmlRelativePath" start

      initLetsEncrypt "$email" "$domain"
    fi

    sudo docker-compose -f "$defaultDockerComposeYmlRelativePath" down

    exitInstaller
  fi

  echo
  echo "ü§ñ ${transl[init_lets_encrypt_reloading_nginx]}..."
  echo

  docker-compose -f "$config_path" exec nginx nginx -s reload

  showOkMessage "${transl[init_lets_encrypt_success_secured_message]}"
}

installMandatory() {
  hasCommand "$1" && return 0

  printf -v prompt "\n\nü§ñ %s\n%s" "${transl[common_install_we_need_to]/_application_/$1}" "${transl[common_install_type_y_or_n]}"
  while read -rp "$prompt"$'\n> ' answer; do
    data=$(confirm "$userSelectedLanguage" "$answer")

    [[ ! $data ]] && continue

    if [[ "$data" -eq 1 ]]; then
      showErrorMessage "${transl[install_mandatory_app_install_required]/_application_/$1}"
      exitInstaller
    elif [[ "$data" -eq 0 ]]; then
      break
    fi
  done

  if [[ "$os" == "linux" ]]; then
    distro=$(identifyDistro)
    if [[ "$distro" == "ubuntu" ]] || [[ "$distro" == "debian" ]]; then
      if ! sudo apt update || ! sudo apt-get install "$1"; then
        exitInstaller
      fi
    elif [[ "$distro" =~ "arch"  ]]; then
      ! sudo pacman -Syu "$1" && exitInstaller
    else
      echo "üëπ ${transl[install_mandatory_distro_not_supported]/_distro_/$distro}"
      echo "${transl[install_mandatory_if_bug_discord]} üôè"
      echo

      exitInstaller
    fi
  fi

  showOkMessage "${transl[install_mandatory_installed]} $1"

  # Add some space after the msg
  printf "\r\n"

  return 0
}

verifyDepsOrInstall() {
  os="$1"
  name="$2"
  bin="$3"
  pkgManager="$4"

  hasCommand "$bin" && return 0

  printf -v prompt "\n\nü§ñ %s\n%s" "${transl[common_install_we_need_to]/_application_/$bin}" "${transl[common_install_type_y_or_n]}"
  while read -rp "$prompt"$'\n> ' answer; do
    data=$(confirm "$userSelectedLanguage" "$answer")

    [[ ! $data ]] && continue

    if [[ "$data" -eq 1 ]]; then
      showErrorMessage "${transl[install_mandatory_app_install_required]/_application_/$1}"
      exitInstaller
    elif [[ "$data" -eq 0 ]]; then
      break
    fi
  done

  if [[ "$ans" == "" ]]; then
    echo "üòÖ ${transl[verify_deps_installed_need_yes_or_no_answer]}"
    
    read -r -p "${transl[common_press_enter_retry]}..."

    verifyDepsOrInstall "$os" "$name" "$bin" "$pkgManager"
  fi

  if [[ "$os" == "linux" ]]; then
    distro=$(identifyDistro)
    pkgManager=$(echo "$pkgManager" | jq ".$distro")
    pkgManagerName=$(echo "$pkgManager" | jq -r ".name")
    pkg=$(echo "$pkgManager" | jq -r ".pkg")

    if [[ $pkgManager =~ "null" || $pkgManagerName =~ "null" || $pkg =~ "null" ]]; then
      echo "üí© ${transl[verify_deps_installed_config_has_missing_values]}"
      echo "LOG: pkgm ($pkgManager), pkgmn ($pkgManagerName), pkg ($pkg)"
      echo
      printf "%s" "${transl[verify_deps_installed_help_us_improve_discord]}" | sed "s/_defaultDiscordUrl_/\"${defaultDiscordUrl}\"/g"

      echo "${transl[verify_deps_installed_thanks_support]} üôè"
      echo

      exitInstaller
    fi

    if [[ "$distro" == "ubuntu" || "$distro" == "debian" ]]; then
      if [[ $pkgManagerName == "snap" ]]; then
        if ! hasCommand "snap"; then
          sudo apt-get install snapd
        fi

        if ! sudo snap install "$pkg"; then
          exitInstaller
        fi

        showOkMessage "${transl[verify_deps_installed_via_package_manager]/_name_/$name} snap"

        # ensure snap is in the PATH and pkgs
        source /etc/profile.d/apps-bin-path.sh

        return 0
      fi

      if ! sudo apt update || ! sudo apt-get install "$pkg"; then
        exitInstaller
      fi

      showOkMessage "${transl[verify_deps_installed_via_package_manager]/_name_/$name} apt-get"

      return 0
    elif [[ "$distro" =~ "arch"  ]]; then
      if [[ $pkgManagerName == "pip" ]]; then
        if ! hasCommand pip; then 
          sudo pacman --noconfirm -Syu python-pip
        fi

        pip install tldextract==3.4.0

        return 0
      fi

      ! sudo pacman --noconfirm -Syu "$pkg" && exitInstaller

      showOkMessage "${transl[verify_deps_installed_via_package_manager]/_name_/$name} pacman"
    fi
  fi
}

extactDomainName() {
  name=$(tldextract "$1" | cut -d " " -f 2)
  tld=$(tldextract "$1" | cut -d " " -f 3)

  domain="$name.$tld"

  echo "$domain"
}

verifyUserHasDomain() {
  printf -v prompt "\n%s?\n%s" \
    "${transl[verify_user_has_domain_have_domain_ready]}" \
    "$(printf "%s" "${transl[verify_user_has_domain_have_domain_ready_yes_or_n_or_q]}" | sed "s/_yes_/\"${transl[common_prompt_yes_as_y]}\"/g; s/_no_/\"${transl[common_prompt_no_as_n]}\"/g")"
  read -r -p "$prompt"$'\n> ' ans

  intlAnswer=$(mapLanguageYesNoQuitToSystem "$userSelectedLanguage" "$ans")

  if [[ "$intlAnswer" == [qQ] ]]; then
    showErrorMessage \
      "$(printf "ü¶ñ %s" "${transl[verify_user_has_domain_user_quit_message]}" | sed "s/_defaultFleekNetworkDocsWebsite_/\"${defaultFleekNetworkDocsWebsite}\"/g")"

    exit 1
  fi

  if [[ ! "$intlAnswer" == "" && "$intlAnswer" == [nN] || "$intlAnswer" == [nN][oO] ]]; then
    printf "\n"

    showErrorMessage "${transl[verify_user_has_domain_oops_best_have_domain]}"

    read -r -p "${transl[common_press_enter_retry]}..."

    verifyUserHasDomain
  fi

  # Domain name handling (start)
  printf -v prompt "\nüí° %s\n\n%s" "${transl[verify_user_has_domain_provide_domain_without_http_1_of_2]}" "${transl[verify_user_has_domain_provide_domain_without_http_2_of_2]}"
  while read -rp "$prompt"$'\n> ' ans; do
    if confirmDomainName "$ans"; then
      userDomainName="$ans"
      break
    fi

    showPoopMessage "${transl[verify_user_has_domain_uh_oh_provide_valid_domain]}..."
  done

  # Ip address handling (start)
  ERROR_IP_ADDRESS_NOT_AVAILABLE="ERROR_IP_ADDRESS_NOT_AVAILABLE"
  detectedIpAddress=$(curl --silent ifconfig.me || curl --silent icanhazip.com || echo "$ERROR_IP_ADDRESS_NOT_AVAILABLE")

  printf -v prompt "\nüí° %s\n\n%s\n\n%s" "${transl[verify_user_has_domain_provide_ip_of_machine_1_of_3]/_detectedIpAddress_/$detectedIpAddress}" "${transl[verify_user_has_domain_provide_ip_of_machine_2_of_3]}" "${transl[verify_user_has_domain_provide_ip_of_machine_3_of_3]}"
  while read -rp "$prompt"$'\n> ' ans; do
    if confirmIpAddress "$ans"; then
      serverIpAddress="$ans"
      break
    elif [[ "$ans" == "" ]]; then
      break
    fi

    showPoopMessage "${transl[verify_user_has_domain_uh_oh_provide_valid_ip]}..."
  done

  # Declare detected ip address as default server ip address
  serverIpAddress=${ans:="$detectedIpAddress"}

  if [[ $serverIpAddress = "$ERROR_IP_ADDRESS_NOT_AVAILABLE" ]]; then
    showErrorMessage "${transl[verify_user_has_domain_oops_embarassing]/_ERROR_IP_ADDRESS_NOT_AVAILABLE_/$ERROR_IP_ADDRESS_NOT_AVAILABLE}"

    exitInstaller
  fi

  # given a name and an ip address, test whether there is a record for name pointing to address
  if ! dig "$userDomainName" +nostats +nocomments +nocmd | tr -d '\t' | grep "A$serverIpAddress" >/dev/null 2>&1 ; then
    showErrorMessage "${transl[verify_user_has_domain_oops_domain_no_dns_record_correct_ip_1_of_2]/_userDomainName_/$userDomainName} ${transl[verify_user_has_domain_oops_domain_no_dns_record_correct_ip_2_of_2]/_serverIpAddress_/$serverIpAddress}"

    read -r -p "${transl[common_press_enter_retry]}..."

    verifyUserHasDomain
  fi

  # Email handling (start)
  printf -v prompt "üí° %s\n%s\n\n%s\n%s\n\n%s" "${transl[verify_user_has_domain_provide_valid_email_1_of_5]}" "${transl[verify_user_has_domain_provide_valid_email_2_of_5]}" "${transl[verify_user_has_domain_provide_valid_email_3_of_5]}" "${transl[verify_user_has_domain_provide_valid_email_4_of_5]}" "${transl[verify_user_has_domain_provide_valid_email_5_of_5]}"
  while read -rp "$prompt"$'\n> ' ans; do
    if confirmEmailAddress "$ans"; then
      emailAddress=$(toLowerCase "$ans")
      break
    fi

    showPoopMessage "${transl[verify_user_has_domain_uh_oh_provide_valid_email]}..."
  done

  printf -v prompt "\nü§ñ %s\n\n%s\n%s\n%s\n\n%s\n%s" \
    "${transl[verify_user_has_domain_details_confirmation_1_of_6]}" \
    "${transl[verify_user_has_domain_details_confirmation_2_of_6]/_userDomainName_/$userDomainName}" \
    "${transl[verify_user_has_domain_details_confirmation_3_of_6]/_serverIpAddress_/$serverIpAddress}" \
    "${transl[verify_user_has_domain_details_confirmation_4_of_6]/_emailAddress_/$emailAddress}" \
    "${transl[verify_user_has_domain_details_confirmation_5_of_6]}" \
    "${transl[verify_user_has_domain_details_confirmation_6_of_6]}"

  while read -rp "$prompt"$'\n> ' ans; do
    intlAnswer=$(mapLanguageYesNoQuitToSystem "$userSelectedLanguage" "$ans")

    case $intlAnswer in
      [yY])
        break
        ;;
      [yY][eE][sS])
        break
        ;;
      [nN])
        verifyUserHasDomain
        break
        ;;
      [nN][oO])
        verifyUserHasDomain
        break
        ;;
    esac;
  done;

  echo "$userDomainName;$emailAddress"

  exit 0
}

replaceNginxConfFileForHttp() {
  echo "
    proxy_cache_path /cache keys_zone=nodecache:100m levels=1:2 inactive=31536000s max_size=10g use_temp_path=off;

    server {
        listen 80;
        listen [::]:80;
        server_name $1;

        location /.well-known/acme-challenge/ {
            root /var/www/certbot;
        }

        location /stub_status {
          stub_status;
        }

        proxy_redirect          off;
        client_max_body_size    10m;
        client_body_buffer_size 128k;
        proxy_connect_timeout   90;
        proxy_send_timeout      90;
        proxy_read_timeout      90;
        proxy_buffers           32 128k;

        location / {
          add_header content-type  application/vnd.ipld.raw;
          add_header content-type  application/vnd.ipld.car;
          add_header content-type  application/octet-stream;
          add_header cache-control public,max-age=31536000,immutable;

          proxy_cache nodecache;
          proxy_cache_valid 200 31536000s;
          add_header X-Proxy-Cache \$upstream_cache_status;
          proxy_cache_methods GET HEAD POST;
          proxy_cache_key \"\$request_uri|\$request_body\";
          client_max_body_size 1G;

          proxy_pass http://ursa:4069;
        }
    }
  " > "$defaultDockerFullNodeRelativePath"/data/nginx/http.conf
}

replaceNginxConfFileForHttps() {
  echo "
    server {
        listen 443 ssl http2;
        listen [::]:443 ssl http2;
        server_name $1;

        server_tokens off;

        # SSL code
        ssl_certificate /etc/letsencrypt/live/$1/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/$1/privkey.pem;

        include /etc/letsencrypt/options-ssl-nginx.conf;
        ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

        location /stub_status {
          stub_status;
        }

        location / {
          add_header content-type  application/vnd.ipld.raw;
          add_header content-type  application/vnd.ipld.car;
          add_header content-type  application/octet-stream;
          add_header cache-control public,max-age=31536000,immutable;

          proxy_cache nodecache;
          proxy_cache_valid 200 31536000s;
          add_header X-Proxy-Cache \$upstream_cache_status;
          proxy_cache_methods GET HEAD POST;
          proxy_cache_key \"\$request_uri|\$request_body\";
          client_max_body_size 1G;


          proxy_pass http://ursa:4069;
        }
    }
  " > "$defaultDockerFullNodeRelativePath"/data/nginx/https.conf
}

setupSSLTLS() {
  echo "‚ö†Ô∏è ${transl[setup_ssl_tls_you_are_required]}"
  echo
  echo "${transl[setup_ssl_tls_visit_your_domain_name_registrar]}"
  echo
  # The extra white space between the ü´° and text is intentional for spacing
  echo "ü´°  ${transl[setup_ssl_tls_complete_step_before_proceeding]}"
  echo "${transl[setup_ssl_tls_reason_to_secure_server]}"
  echo
  echo "üôè ${transl[setup_ssl_tls_learn_more_about]}"
  printf "\n"

  trimData=$(verifyUserHasDomain | xargs)

  if [[ ! "$trimData" ]]; then
    showErrorMessage "ü¶ñ ${transl[setup_ssl_tls_failed_verify_user_domain_and_email]}..."

    exit 1
  fi

  userDomainName=$(echo "$trimData" | cut -d ";" -f 1)
  emailAddress=$(echo "$trimData" | cut -d ";" -f 2)

  if ! rm "$defaultDockerFullNodeRelativePath"/data/nginx/app.conf; then
    showErrorMessage "${transl[setup_ssl_tls_oops_failed_clear_nginx]} üôè"

    exitInstaller
  fi

  if ! replaceNginxConfFileForHttp "$userDomainName"; then
    showErrorMessage "${transl[setup_ssl_tls_oops_failed_update_http_server_name]/_userDomainName_/$userDomainName} üôè"

    exitInstaller
  fi

  chmod +x "$defaultDockerFullNodeRelativePath"/init-letsencrypt.sh

  showOkMessage "${transl[setup_ssl_tls_updated_file_permissions_lets_encrypt_execution]} (set +x)!"

  # Intentional, used to provide space after msg
  echo

  # start stack in bg, as lets encrypt will need the nginx to validate
  COMPOSE_DOCKER_CLI_BUILD=1 sudo docker-compose -f "$defaultDockerComposeYmlRelativePath" up -d

  # TODO: add health check in the docker compose file

  # Health check
  statusCode=$(curl --write-out "%{http_code}" --silent --output /dev/null http://"$userDomainName"/ping)

  if [[ "$statusCode" -ne 200 ]]; then
    showPoopMessage "${transl[setup_ssl_tls_uh_oh_cant_communicate_with_reverse_proxy]}"

    read -r -p "üòÖ ${transl[setup_ssl_tls_lets_encrypt_likely_fail_if_continue]}..."
  fi

  if ! initLetsEncrypt "$emailAddress" "$userDomainName"; then
    exitInstaller
  fi

  printf "\n"

  if ! replaceNginxConfFileForHttps "$userDomainName"; then
    showErrorMessage "${transl[setup_ssl_tls_oops_failed_update_https_server_name_directive]/_userDomainName_/$userDomainName} üôè"

    exitInstaller
  fi
}

changeDirectoryToPathOrFailure() {
  local name=$1
  local targetPath=$2

  if [[ -z "$name" || -z "$targetPath" ]]; then
    showErrorMessage "${transl[change_directory_to_path_oops_failed_change_dir_discord]} üôè"

    exitInstaller
  fi

  if [[ $(pwd) != "$targetPath" ]]; then
    if ! cd "$targetPath"; then
      showErrorMessage "${transl[change_directory_to_path_oops_failed_change_dir_to_name]/_name_/$name} üôè"

      exitInstaller
    fi
  fi
}

onNightlyPreference() {
  echo
  echo "‚úã ${transl[on_nightly_preference_when_running_stack_docker_build]}"
  echo "üí° ${transl[on_nightly_preference_our_recommendation]} üò¥!"
  echo
  echo "${transl[on_nightly_preference_inf_future_check_documentation]}"
  echo

  printf -v prompt "\n\nü§ñ %s\n%s" \
    "${transl[on_nightly_preference_prompt_happy_use_nightly]}" \
    "$(printf "%s" "${transl[on_nightly_preference_prompt_happy_use_nightly_yes_or_no]}" | sed "s/_yes_/\"${transl[common_prompt_yes_as_y]}\"/g; s/_no_/\"${transl[common_prompt_no_as_n]}\"/g")"
  while read -rp "$prompt"$'\n> ' ans; do
    data=$(confirm "$userSelectedLanguage" "$ans")

    [[ ! $data ]] && continue

    if [[ "$data" -eq 1 ]]; then
      echo
      echo "ü¶Ä ${transl[on_nightly_preference_mind_ursa_time_build_long]}..."
      echo

      break
    elif [[ "$data" -eq 0 ]]; then
      yq -ie 'del(.services.ursa.build)' "$defaultDockerComposeYmlRelativePath" >/dev/null 2>&1
      yq -i ".services.ursa.image = \"$defaultUrsaNightlyImage\"" "$defaultDockerComposeYmlRelativePath" >/dev/null 2>&1

      if ! yq '.services.ursa.image' "$defaultDockerComposeYmlRelativePath" | grep -q "$defaultUrsaNightlyImage" || ! yq '.services.ursa.build' "$defaultDockerComposeYmlRelativePath" | grep -qE "null|no matches found"; then
        echo
        echo "üí© ${transl[on_nightly_preference_uh_oh_failed_modify_docker_compose_yaml]}"

        printf "%s üôè" "${transl[on_nightly_preference_uh_oh_failed_modify_docker_compose_yaml_apologies]}" | sed "s/_defaultDiscordUrl_/\"${defaultDiscordUrl}\"/g"
        echo

        exitInstaller
      fi

      break
    fi
  done
}

(
  # stdin to keyboard
  exec < /dev/tty;

  # SIGINT listener
  trap onInterruption INT

  # Identity the OS
  os=$(identifyOS)

  isOSSupported "$os"

  # Show disclaimer
  showDisclaimer

  # Had space after disclaimer
  printf "\r\n"

  # Check if system has recommended resources (disk space and memory)
  checkSystemHasRecommendedResources "$os"

  # Check if has dependencies installed
  for dep in "${dependencies[@]}"; do
    installMandatory "$dep"
  done

  for dep in $(echo "${config}" | jq -r '.dependencies[] | @base64'); do
    name=$(getJQPropertyValue "$dep" ".name")
    bin=$(getJQPropertyValue "$dep" ".bin")
    pkgManager=$(getJQPropertyValue "$dep" ".pkgManager")

    verifyDepsOrInstall "$os" "$name" "$bin" "$pkgManager"
  done

  # We start by verifying if git is installed, if not request to install
  checkIfGitInstalled "$os"

  gitHealthCheck

  # Verify if Docker is installed, if not install it
  checkIfDockerInstalled "$os"

  # Request a pathname where to store the Ursa repository, otherwise provide a default
  ursaPath=$(requestPathnameForUrsaRepository)

  # Check if directory does not exit or empty
  if [[ "$(ls -A "$ursaPath" >/dev/null 2>&1)" ]]; then
    echo
    echo "üòÖ ${transl[on_nightly_preference_have_run_install_before_surprise]}"
    echo
    echo "${transl[on_nightly_preference_directory_not_empty]/_ursaPath_/$ursaPath}"
    echo "${transl[on_nightly_preference_if_stuck_clear_location_1_of_2]}"
    echo "${transl[on_nightly_preference_if_stuck_clear_location_2_of_2]/_defaultUrsaPath_/$defaultUrsaPath}"

    exitInstaller
  fi

  # Pull the `ursa` project repository to the preferred target directory via HTTPS
  cloneUrsaRepositoryToPath "$ursaPath"
  changeDirectoryToPathOrFailure "Ursa" "$ursaPath"

  #¬†Await a few seconds to let the user read...
  sleep 5

  # Recommend the Nightly build to speed up onboarding
  onNightlyPreference

  # Add some space after the "nightly" request
  printf "\r\n"

  # Optional, check if user would like to setup SSL/TLS
  setupSSLTLS

  showOkMessage "${transl[on_nightly_preference_success_install_completed]}"

  # Add some space after the "complete" message
  printf "\r\n"
  
  #¬†Await a few seconds to let the user read...
  sleep 5

  # Restart docker
  restartDockerStack

  # Set installation has complet
  installationStatus="$statusComplete"

  # Add some space after the "docker stack restart" message
  printf "\r\n"

  # Show the logs
  showDockerStackLog
  
  resetStyles
  exit;
)