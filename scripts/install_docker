#!/bin/bash

# <!-- IGNORE: This line is intentional DO NOT MODIFY --><pre><script>document.querySelector('body').firstChild.textContent = '#!/bin/bash'</script>

# "Get Fleek Network" is an attempt to make our software more accessible.
# By providing scripts to automate the installation process of our software,
# we believe that it can help improve the onboarding experience of our users.
#
# Quick install: `curl https://get.fleek.network | bash`
#
# This script automates the process illustrated in our guide "Running a Node in a Docker container"
# advanced users might find it better to follow the instructions in the guide
# If that's your preference, go ahead and check our guides https://docs.fleek.network
#
# For the users happy to have the script assist in the installation process of Fleek Network
# and the required dependencies, run the script at your own risk. Part of the project will
# verify if specific dependencies are installed or needed, but it won't try to customise or
# take into consideration your custom environment. If you have a custom environment, then
# is best to follow the instructions in our guide, as otherwise risk changing
# or overriding your custom setup.
#
# Ideally, the script will:
# - Check if the system has enough disk space and memory, otherwise warn the user
# - Verify if the user is in Docker, as Docker in Docker is not supported
# - Verify if Git is installed, if not install it
# - It'll do a quick health check to confirm Git is installed correctly 
# - Verify if Docker is installed, if not install it
# - It'll do a quick health check to confirm Docker is installed correctly
# - Request a pathname where to store the Ursa repository, otherwise providing a default,
#   e.g., `$HOME/fleek-network/ursa`
# - Pull the `ursa` project repository to the preferred target directory via HTTPS
#   instead of SSH for simplicity
# - Optionally, assist in setting up and securing domain name via SSL/TLS
# - Run the Docker stack
#¬†- Do a health check to confirm the Fleek Network Node is running
#
# Contributing?
# - If you'd like to test changes locally use the env var `USE_BRANCH_NAME_FOR_GH_RAW` and `URSA_BRANCH`, for remote locales pulls
#
# Found an issue? Please report it here: https://github.com/fleek-network/get.fleek.network

# üöë Check if running in Bash and supported version
[ "$BASH" ] || { printf >&2 'üôè Run the script with Bash, please!\n'; exit 1; }
(( BASH_VERSINFO[0] > 4 || BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] >= 2 )) || { printf >&2 'üôè Bash 4.2 or newer is required!\n'; exit 1; }

# Date
dateRuntime=$(date '+%Y%m%d%H%M%S')

# Default
defaultGetFleekNetworkUrl="https://get.fleek.network"
defaultFleekNetworkWebsite="https://fleek.network"
defaultFleekNetworkDocsWebsite="https://docs.fleek.network"
defaultDiscordUrl="https://discord.gg/fleekxyz"
defaultFleekNetworkTwitterUrl="https://twitter.com/fleek_net"
defaultGetFleekNetworkRepository="https://github.com/fleek-network/get.fleek.network"
defaultUrsaHttpsRepository="https://github.com/fleek-network/ursa.git"
defaultUrsaPath="$HOME/fleek-network/ursa"
defaultGHCRImagePlaceholderUrl="ghcr.io/fleek-network/_imageName_:latest"
defaultDockerFullNodeRelativePath="./docker/full-node"
defaultDockerComposeYmlRelativePath="$defaultDockerFullNodeRelativePath/docker-compose.yml"
defaultMinMemoryKBytesRequired=8000000
defaultMinDiskSpaceKBytesRequired=1000000
defaultUrsaConfigFilename="config.toml"
#¬†Obs: For Docker users and sudoers, as otherwise $HOME/.ursa will not be populated, 
# since exec with sudo generates /root/.ursa and can cause confusion
# Users can customise this paths by reading the file permission guide
# https://docs.fleek.network/guides/Network%20nodes/securing-the-ursa-files
defaultUrsaBasePath="/root/.ursa"
defaultUrsaConfigPath="$defaultUrsaBasePath/$defaultUrsaConfigFilename"
defaultDockerDaemonJson="/etc/docker/daemon.json"
defaultUrsaProxyDir="$defaultUrsaBasePath/proxy"
defaultUrsaProxyConfigPath="$defaultUrsaProxyDir/config.toml"
defaultLetsEncryptCertificatesLivePath="/etc/letsencrypt/live"
defaultDockerNetworkUrsaHostname="full-node-ursa-1"
defaultDockerNetworkUrsaProxyHostname="full-node-ursa-proxy-1"

# App state
userSelectedLanguage=""
selectedUrsaPath=""
serverIpAddress=""

# Localization
declare -a supportedLanguages=("en" "ch" "es" "pt" "fr" "it" "vi" "jp" "ko" "de" "hi" "ru")

for lang in "${supportedLanguages[@]}"; do
  # use of ?dateRuntime intentional, prevent cache, do not modify
  # INFO: set `USE_BRANCH_NAME_FOR_GH_RAW` to use the Github raw locales for testing
  # e.g., USE_BRANCH_NAME_FOR_GH_RAW="feat/localization" ./install
  if [[ -n ${USE_BRANCH_NAME_FOR_GH_RAW+x} ]]; then
    . <(curl -s "https://raw.githubusercontent.com/fleek-network/get.fleek.network/$USE_BRANCH_NAME_FOR_GH_RAW/locales/$lang?$dateRuntime")

    continue;
  fi

  . <(curl -s "$defaultGetFleekNetworkUrl/locales/$lang?$dateRuntime")
done

# App text translations
declare -A transl=()

setLang() {
  declare -n _selectedLang="$1"
  for key in "${!_selectedLang[@]}"; do
    transl["$key"]=${_selectedLang[$key]}
  done
  
  userSelectedLanguage="$1"
}

multiLanguageChoice() {
  echo ""
  printf "\n\n%s\n\n" "üëã Hello / ‰Ω†Â•Ω / Hola / Ol√° / Bonjour / Ciao / Xin ch√†o / „Åì„Çì„Å´„Å°„ÅØ / ÏïàÎÖïÌïòÏÑ∏Ïöî / Hallo / ‡§®‡§Æ‡§∏‡•ç‡§§‡•á / –ü—Ä–∏–≤–µ—Ç"
  printf "%s\n\n" "üôè Select your preferred language from the list / ‰ªéÂàóË°®‰∏≠ÈÄâÊã©ÊÇ®ÁöÑÈ¶ñÈÄâËØ≠Ë®Ä / Seleccione su idioma preferido de la lista / Selecione seu idioma preferido na lista / S√©lectionnez votre langue pr√©f√©r√©e dans la liste / Seleziona la tua lingua preferita dall'elenco / Ch·ªçn ng√¥n ng·ªØ ∆∞a th√≠ch c·ªßa b·∫°n t·ª´ danh s√°ch / „É™„Çπ„Éà„Åã„Çâ„ÅîÂ∏åÊúõ„ÅÆË®ÄË™û„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ / Î™©Î°ùÏóêÏÑú ÏÑ†Ìò∏ÌïòÎäî Ïñ∏Ïñ¥Î•º ÏÑ†ÌÉùÌïòÏã≠ÏãúÏò§ / W√§hlen Sie Ihre bevorzugte Sprache aus der Liste aus / ‡§∏‡•Ç‡§ö‡•Ä ‡§∏‡•á ‡§Ö‡§™‡§®‡•Ä ‡§™‡§∏‡§Ç‡§¶‡•Ä‡§¶‡§æ ‡§≠‡§æ‡§∑‡§æ ‡§ï‡§æ ‡§ö‡§Ø‡§® ‡§ï‡§∞‡•á‡§Ç / –í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º—ã–π —è–∑—ã–∫ –∏–∑ —Å–ø–∏—Å–∫–∞"
  printf "%s\n" " 1) üá¨üáß  English"
  printf "%s\n" " 2) üá®üá≥  ‰∏≠Êñá"
  printf "%s\n" " 3) üá™üá∏  Espa√±ol"
  printf "%s\n" " 4) üáµüáπ  Portugu√™s"
  printf "%s\n" " 5) üá´üá∑  Fran√ßais"
  printf "%s\n" " 6) üáÆüáπ  Italiano"
  printf "%s\n" " 7) üáªüá≥  Ti·∫øng Vi·ªát"
  printf "%s\n" " 8) üáØüáµ  Êó•Êú¨Ë™û"
  printf "%s\n" " 9) üá∞üá∑  ÏïàÎÖïÌïòÏÑ∏Ïöî"
  printf "%s\n" "10) üá©üá™  Deutsch"
  printf "%s\n" "11) üáÆüá≥  ‡§π‡§ø‡§Ç‡§¶‡•Ä"
  printf "%s\n" "12) üá∑üá∫  P—É—Å—Å–∫–∏–π"
  echo ""

  while read -r -p "> " ans; do  
    if [[ $ans == [eE]nglish || $ans == 1 ]]; then
      opt="en"
    elif [[ $ans =~ ‰∏≠Êñá || $ans == 2 ]]; then
      opt="ch"
    elif [[ $ans == [eE]spa√±ol || $ans == 3 ]]; then
      opt="es"
    elif [[ $ans == [pP]ortugu√™s || $ans == 4 ]]; then
      opt="pt"
    elif [[ $ans == [fF]ran√ßais || $ans == 5 ]]; then
      opt="fr"
    elif [[ $ans == [iI]taliano || $ans == 6 ]]; then
      opt="it"
    elif [[ $ans =~ [tT]i·∫øng || $ans == 7 ]]; then
      opt="vi"
    elif [[ $ans =~ Êó•Êú¨Ë™û || $ans == 8 ]]; then
      opt="jp"
    elif [[ $ans =~ ÏïàÎÖïÌïòÏÑ∏Ïöî || $ans == 9 ]]; then
      opt="ko"
    elif [[ $ans =~ [dD]eutsch || $ans == 10 ]]; then
      opt="de"
    elif [[ $ans =~ ‡§π‡§ø‡§Ç‡§¶‡•Ä || $ans == 11 ]]; then
      opt="hi"
    elif [[ $ans == [pP]—É—Å—Å–∫–∏–π || $ans == 12 ]]; then
      opt="ru"
    fi

    if [[ ! $opt ]]; then
      echo
      read -rp "ü¶ñ A language was not selected, will default to üá¨üáß  English. Press ENTER to continue..."

      setLang "en"

      break;
    fi

    if [[ "${supportedLanguages[*]}" =~ $opt ]]; then
      setLang "$opt"

      break;
    fi
  done
}

# Installer state
statusComplete="complete"
installationStatus=""

# Installer script dependencies
# e.g. jq as used to iterate the config
declare -a dependencies=("jq")

# Config (json)
config='{
  "dependencies": [
    {
      "name": "Yq - Cli YAML, JSON, XML, CSV",
      "bin": "yq",
      "pkgManager": {
        "arch": {
          "pkg": "go-yq",
          "name": "pacman"
        },
        "debian": {
          "pkg": "yq",
          "name": "snap"
        },
        "ubuntu": {
          "pkg": "yq",
          "name": "snap"
        }
      }
    },
    {
      "name": "Whois - Internet domain name and network number directory service",
      "bin": "whois",
      "pkgManager": {
        "arch": {
          "pkg": "whois",
          "name": "pacman"
        },
        "debian": {
          "pkg": "whois",
          "name": "apt-get"
        },
        "ubuntu": {
          "pkg": "whois",
          "name": "apt-get"
        }
      }
    },
    {
      "name": "tldextract-rs cli - extract tld info from url",
      "bin": "tldextract",
      "pkgManager": {
        "arch": {
          "pkg": "tldextract",
          "name": "pip"
        },
        "debian": {
          "pkg": "tldextract",
          "name": "apt-get"
        },
        "ubuntu": {
          "pkg": "tldextract",
          "name": "apt-get"
        }
      }
    },
    {
      "name": "dig - DNS lookup utility",
      "bin": "dig",
      "pkgManager": {
        "arch": {
          "pkg": "dnsutils",
          "name": "pacman"
        },
        "debian": {
          "pkg": "dnsutils",
          "name": "apt-get"
        },
        "ubuntu": {
          "pkg": "dnsutils",
          "name": "apt-get"
        }
      }
    }
  ]
}'

# Style utils
txtPrefixForBold=$(tput bold)
txtPrefixForNormal=$(tput sgr0)

mapLanguageYesNoQuitToSystem() {
  if [[ "$1" == "en" ]]; then
    echo "$2"

    return
  fi

  if [[ "$1" == "ch" ]]; then
    case "${2}" in
      ÊòØÁöÑ)    typed="y";;
      ‰∏ç)    typed="n";;
      ËæûËÅå)    typed="q";;
      [sS]kip)  typed="skip";;
      *)        typed="$2"
    esac

    echo "$typed"

    return
  fi

  if [[ "$1" == "es" ]]; then
    case "${2}" in
      [sS])    typed="y";;
      [sS]√≠)    typed="y";;
      [sS]i)    typed="y";;
      [nN])    typed="n";;
      [nN]o)    typed="n";;
      [aA]bandonar)    typed="q";;
      [sS]altar)  typed="skip";;
      [sS]kip)  typed="skip";;
      *)        typed="$2"
    esac

    echo "$typed"

    return
  fi

  if [[ "$1" == "pt" ]]; then
    case "${2}" in
      [sS])    typed="y";;
      [sS]im)    typed="y";;
      [nN])    typed="n";;
      [nN]√£o)    typed="n";;
      [nN]ao)    typed="n";;
      [dD]esistir)    typed="q";;
      [sS]kip)  typed="skip";;
      *)        typed="$2"
    esac

    echo "$typed"

    return
  fi

  if [[ "$1" == "fr" ]]; then
    case "${2}" in
      Oui)    typed="y";;
      Non)    typed="n";;
      "arr√™ter")    typed="q";;
      [sS]kip)  typed="skip";;
      *)        typed="$2"
    esac

    echo "$typed"

    return
  fi

  if [[ "$1" == "it" ]]; then
    case "${2}" in
      [sS][√¨√å])    typed="y";;
      [nN][oO])    typed="n";;
      "esentata")    typed="q";;
      [sS]kip)  typed="skip";;
      *)        typed="$2"
    esac

    echo "$typed"

    return
  fi

  if [[ "$1" == "vi" ]]; then
    case "${2}" in
      ƒê√∫ng)    typed="y";;
      KH√îNG)    typed="n";;
      "t·ª´ b·ªè")    typed="q";;
      [sS]kip)  typed="skip";;
      *)        typed="$2"
    esac

    echo "$typed"

    return
  fi

  if [[ "$1" == "jp" ]]; then
    case "${2}" in
      „ÅØ„ÅÑ)    typed="y";;
      „ÅÑ„ÅÑ„Åà)    typed="n";;
      „ÇÑ„ÇÅ„Çã)    typed="q";;
      [sS]kip)  typed="skip";;
      *)        typed="$2"
    esac

    echo "$typed"

    return
  fi

  if [[ "$1" == "ko" ]]; then
    case "${2}" in
      Ïòà)    typed="y";;
      ÏïÑÎãàÏöî)    typed="n";;
      Í∑∏ÎßåÎëêÎã§)    typed="q";;
      [sS]kip)  typed="skip";;
      *)        typed="$2"
    esac

    echo "$typed"

    return
  fi

  if [[ "$1" == "de" ]]; then
    case "${2}" in
      ja)    typed="y";;
      NEIN)    typed="n";;
      aufh√∂ren)    typed="q";;
      [sS]kip)  typed="skip";;
      *)        typed="$2"
    esac

    echo "$typed"

    return
  fi

  if [[ "$1" == "hi" ]]; then
    case "${2}" in
      ‡§π‡§æ‡§Å)    typed="y";;
      ‡§®‡§π‡•Ä‡§Ç)    typed="n";;
      ‡§õ‡•ã‡§°‡§º‡§®‡§æ)    typed="q";;
      [sS]kip)  typed="skip";;
      *)        typed="$2"
    esac

    echo "$typed"

    return
  fi

  if [[ "$1" == "ru" ]]; then
    case "${2}" in
      –¥–∞)    typed="y";;
      –Ω–µ—Ç)    typed="n";;
      –ø–æ–∫–∏–¥–∞—Ç—å)    typed="q";;
      [sS]kip)  typed="skip";;
      *)        typed="$2"
    esac

    echo "$typed"

    return
  fi
}

dockerComposeExec() {
  if docker compose version >/dev/null 2>&1; then
    sudo docker compose "$@"
  else
    sudo docker-compose "$@"
  fi
}

yqExec() {
  if ! sudo yq "$@" >/dev/null 2>&1; then
    if ! sudo /snap/bin/yq "$@"; then
      echo "üòÖ The yq fallback failed"
    fi
  fi
}

# Confirm validators
confirmDomainName() {
  local validate="^([a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]\.)+[a-zA-Z]{2,}$"

  if whois "$1" | grep -Ei '[Uu]nallocated|returned 0 objects' > /dev/null; then
    return 1
  fi

  [[ $1 =~ $validate ]]
}

confirmIpAddress() {
  local validate="^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$"

  [[ "$1" =~ $validate ]] && ping -c1 -W1 "$1" > /dev/null
}

confirmEmailAddress() {
  local validate="^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]+$"

  [[ "$1" =~ $validate ]]
}

confirm() {
  intlAnswer=$(mapLanguageYesNoQuitToSystem "$1" "$2")

  case $intlAnswer in
    [yY])
      echo 0
      ;;
    [yY][eE][sS])
      echo 0
      ;;
    [nN])
      echo 1
      ;;
    [nN][oO])
      echo 1
      ;;
  esac;
}

resetStyles() {
  echo "${txtPrefixForNormal}"
}

exitInstaller() {
  resetStyles
  exit 1;
}

hasCommand() {
  command -v "$1" >/dev/null 2>&1
}

clearScr() {
  printf '\e[H\e[2J'
}

launchAsciiArt() {
  printf "\r\n"

  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ"
  echo
  echo "‚ö°Ô∏è ${transl[ascii_art_fleek_team_presents]} ‚ö°Ô∏è"
  echo

# the cat and ascii art (ART, as `here tag``)
# is intentionally positioned to the most left
#¬†do not change
cat << "ART"
        _..._
      .'     '.     _
    /    .-""-\   _/ \
  .-|   /:.   |  |   |
  |  \  |:.   /.-'-./
  | .-'-;:__.'    =/
  .'=  *=|URSA _.='
  /   _.  |    ;
  ;-.-'|    \   |
/   | \    _\  _\
\__/'._;.  ==' ==\
        \    \   |
        /    /   /
        /-._/-._/
        \   `\  \
          `-._/._/
ART
# üëÜ ART (here tag) end positioned to the most left intentionally

  echo
  echo "‚≠êÔ∏è Ursa, a Decentralized Content Delivery Network (DCDN) ‚≠êÔ∏è"
  echo
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ üåç ${txtPrefixForBold}Website ${txtPrefixForNormal}https://fleek.network"
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ üìö ${txtPrefixForBold}Documentation ${txtPrefixForNormal}https://docs.fleek.network"
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ üíæ ${txtPrefixForBold}Git repository ${txtPrefixForNormal}https://github.com/fleek-network/ursa"
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ ü§ñ ${txtPrefixForBold}Discord ${txtPrefixForNormal}https://discord.gg/fleekxyz"
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ üê§ ${txtPrefixForBold}Twitter ${txtPrefixForNormal}https://twitter.com/fleek_net"
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ üé® ${txtPrefixForBold}Ascii art by ${txtPrefixForNormal}https://www.asciiart.eu"
}


asciiArtNoOSSupport() {
# the cat and ascii art (ART, as `here tag``)
# is intentionally positioned to the most left
#¬†do not change
cat << "ART"
.     .       .  .   . .   .   . .    +  .
  .     .  :     .    .. :. .___---------___.
       .  .   .    .  :.:. _".^ .^ ^.  '.. :"-_. .
    .  :       .  .  .:../:            . .^  :.:\.
        .   . :: +. :.:/: .   .    .        . . .:\
 .  :    .     . _ :::/:               .  ^ .  . .:\
  .. . .   . - : :.:./.                        .  .:\
  .      .     . :..|:                    .  .  ^. .:|
    .       . : : ..||        .                . . !:|
  .     . . . ::. ::\(                           . :)/
 .   .     : . : .:.|. ######              .#######::|
  :.. .  :-  : .:  ::|.#######           ..########:|
 .  .  .  ..  .  .. :\ ########          :######## :/
  .        .+ :: : -.:\ ########       . ########.:/
    .  .+   . . . . :.:\. #######       #######..:/
      :: . . . . ::.:..:.\           .   .   ..:/
   .   .   .  .. :  -::::.\.       | |     . .:/
      .  :  .  .  .-:.":.::.\             ..:/
 .      -.   . . . .: .:::.:.\.           .:/
.   .   .  :      : ....::_:..:\   ___.  :/
   .   .  .   .:. .. .  .: :.:.:\       :/
     +   .   .   : . ::. :.:. .:.|\  .:/|
     .         +   .  .  ...:: ..|  --.:|
.      . . .   .  .  . ... :..:.."(  ..)"
 .   .       .      :  .   .: ::/  .  .::\
ART
# üëÜ ART (here tag) end positioned to the most left intentionally

  echo
  echo "üëæ ${transl[ascii_art_no_os_support_alien_technosignature]} üëæ"
  echo

  sleep 3
}

requestAuthorizationAndExec() {
  printf -v prompt "\nü§ñ %s (%s/%s)?" \
    "$1" \
    "${transl[common_prompt_yes_as_y]}" \
    "${transl[common_prompt_no_as_n]}"
  read -r -p "$prompt"$'\n> ' answer

  intlAnswer=$(mapLanguageYesNoQuitToSystem "$userSelectedLanguage" "$answer")

  if [[ "$intlAnswer" == [nN] || "$intlAnswer" == [nN][oO] ]]; then
    printf "\n\n"

    showErrorMessage "$2"

    exitInstaller
  fi

  printf "\n\n"

  $3
}

onExitInstallerTodos() {
  resetStyles
}

onInterruption() {
  # Only show warning message if install NOT complete
  if [[ "$installationStatus" != "$statusComplete" ]]; then
    printf "\r\n"
    echo "üò¨ ${transl[on_interruption_ouch_error]}"
    echo
    printf "%s" "${transl[on_interruption_if_require_support]}" | sed "s|_defaultDiscordUrl_|\"${defaultDiscordUrl}\"|g"

    onExitInstallerTodos
    exit 1
  fi

  onExitInstallerTodos
  exit 0
}

toLowerCase() {
  echo "$1" | tr '[:upper:]' '[:lower:]'
}

showOkMessage() {
  printf "\r\n‚úÖ %s\n" "$1"  
}

showErrorMessage() {
  printf "\r\nüö© %s\n" "$1" >&2
}

showPoopMessage() {
  printf "\r\nüí© %s\n" "$1" >&2
}

showHintMessage() {
  printf "\r\nüí° %s\n" "$1"  
}

showDisclaimer() {
  # Display artwork
  launchAsciiArt

  printf "\r\n\n"
  echo "‚≠êÔ∏è ${transl[show_disclaimer_title]}"
  echo
  echo "${transl[show_disclaimer_if_happy]}"
  echo
  printf "%s üëÄ." "${transl[show_disclaimer_script_repository]}" | sed "s|_defaultGetFleekNetworkRepository_|\"${defaultGetFleekNetworkRepository}\"|g"
  echo
  echo "ü§ì ${transl[show_disclaimer_more]}"
  printf "%s" \
    "$(printf "%s" "${transl[show_disclaimer_guides]}" | sed "s|_defaultFleekNetworkDocsWebsite_|\"${defaultFleekNetworkDocsWebsite}\"|g; s|_defaultGetFleekNetworkRepository_|${defaultGetFleekNetworkRepository}|g")"

  printf -v prompt "\n\nü§ñ %s?\n%s" \
    "$(printf "%s" "${transl[show_disclaimer_should_continue]}" | sed "s|_yes_|\"${transl[common_prompt_yes_as_y]}\"|g; s|_no_|\"${transl[common_prompt_no_as_n]}\"|g")" \
    "$(printf "%s" "${transl[show_disclaimer_should_yes_or_no_quit]}" | sed "s|_yes_|\"${transl[common_prompt_yes_as_y]}\"|g; s|_no_|\"${transl[common_prompt_no_as_n]}\"|g")"
  while read -rp "$prompt"$'\n> ' ans; do
    data=$(confirm "$userSelectedLanguage" "$ans")

    [[ ! $data ]] && continue

    if [[ "$data" -eq 1 ]]; then
      echo
      echo "ü¶ñ ${transl[show_disclaimer_terminates_here]}"
      echo
      printf "%s" \
        "$(printf "%s" "${transl[show_disclaimer_terminates_otherwise]}" | sed "s|_defaultFleekNetworkWebsite_|\"${defaultFleekNetworkWebsite}\"|g")"    
      echo

      exitInstaller
    elif [[ "$data" -eq 0 ]]; then
      break
    fi
  done
}

commonWarningMessage() {
  echo "${transl[common_warning_msg_try_support]}"
  printf "%s" \
    "$(printf "%s" "${transl[common_warning_msg_information_declassified]}" | sed "s|_defaultFleekNetworkTwitterUrl_|\"${defaultFleekNetworkTwitterUrl}\"|g")"    
  echo
  echo "${transl[common_warning_msg_check_guides]}"
  echo
  printf "%s" \
    "$(printf "%s" "${transl[common_warning_msg_visit_docs]}" | sed "s|_defaultFleekNetworkDocsWebsite_|\"${defaultFleekNetworkDocsWebsite}\"|g")"    
}

windowsUsersWarning() {
  asciiArtNoOSSupport
  echo "‚ö†Ô∏è ${transl[windows_users_warning_not_supported]}"
  echo "${transl[windows_users_warning_if_not_enable_wsl]}"
  echo
  commonWarningMessage
}

macOsUsersWarning() {
  asciiArtNoOSSupport
  echo "‚ö†Ô∏è ${transl[macos_users_warning_not_supported]}"
  echo
  echo "${transl[macos_users_warning_has_discontinued]}"
  echo
  commonWarningMessage
}

getJQPropertyValue() {
  echo "${1}" | base64 --decode | jq -r "${2}"
}

installGit() {
  os=$(identifyOS)

  if [[ "$os" == "linux" ]]; then
    distro=$(identifyDistro)

    if [[ "$distro" == "ubuntu" ]] || [[ "$distro" == "debian" ]]; then
      sudo DEBIAN_FRONTEND=noninteractive apt-get install git -yq
    elif [[ "$distro" =~ "arch"  ]]; then
      sudo pacman -Syu git
    else
      showErrorMessage \
        "$(printf "%s" "${transl[install_git_oops_os_and_distro]}" | sed "s|_os_|\"${os}\"|g; s|_distro_|\"${distro}\"|g; s|_defaultFleekNetworkDocsWebsite_|${defaultFleekNetworkDocsWebsite}|g")"

      exitInstaller
    fi
  else
    showErrorMessage \
      "$(printf "%s" "${transl[install_git_oops_os]}" | sed "s|_os_|\"${os}\"|g; s|_defaultFleekNetworkDocsWebsite_|${defaultFleekNetworkDocsWebsite}|g")"

    exitInstaller
  fi
}

identifyOS() {
  unameOut="$(uname -s)"

  case "${unameOut}" in
      Linux*)     os=Linux;;
      Darwin*)    os=Mac;;
      CYGWIN*)    os=Cygwin;;
      MINGW*)     os=MinGw;;
      *)          os="UNKNOWN:${unameOut}"
  esac

  osToLc=$(toLowerCase "$os")

  echo "$osToLc"
}

isOSSupported() {
  if [[ "$1" == "cygwin" ]] || [[ "$1" == "mingw" ]]; then
    printf "\n"

    windowsUsersWarning

    exitInstaller
  fi

  if [[ "$1" == "mac" ]]; then
    printf "\n"

    macOsUsersWarning

    exitInstaller
  fi

  if [[ "$1" == "ubuntu" ]]; then
    currVersion=$(lsb_release -r -s | tr -d '.')

    if [[ "$currVersion" -lt "2204" ]]; then
      echo
      echo "üëπ ${transl[is_os_supported_oops_need_ubuntu]}"
      echo

      exitInstaller
    fi

    if dpkg -l ubuntu-desktop; then
      echo
      echo "‚ö†Ô∏è Desktop operating systems are not supported at this time!"
      echo "Most Desktop computers have a dynamic IP address and a domain name's required to secure the server with SSL/TLS."
      echo

      read -rp "Continue at your own risk. Press ENTER to continue..."
    fi

    if grep -q Microsoft /proc/version; then
      echo
      echo "‚ö†Ô∏è Windows Subsystem Linux detected (WSL), desktop operating systems are not supported at this time!"
      echo "Most Desktop computers have a dynamic IP address and a domain name's required to secure the server with SSL/TLS."
      echo

      read -rp "Continue at your own risk. Press ENTER to continue..."
    fi
  fi

  if [[ "$1" == "debian" ]]; then
    currVersion=$(lsb_release -r -s | tr -d '.')

    if [[ "$currVersion" -lt "11" ]]; then
      echo
      echo "üëπ ${transl[is_os_supported_oops_need_debian]}"
      echo

      exitInstaller
    fi
  fi
}

identifyDistro() {
  if [[ -f /etc/os-release ]]; then
    source /etc/os-release
    echo "$ID"

    exit 0
  fi
  
  uname
}

checkSystemHasRecommendedResources() {
  mem=$(awk '/^MemTotal:/{print $2}' /proc/meminfo);
  partDiskSpace=$(df --output=avail -B 1 "$PWD" |tail -n 1)

  if [[ ("$mem" -lt "$defaultMinMemoryKBytesRequired") ]] || [[ ( "$partDiskSpace" -lt "$defaultMinDiskSpaceKBytesRequired" ) ]]; then
    echo "üò¨ ${transl[check_sys_has_recommended_resources_oh_no_need_at_least]}"
    echo
    printf -v prompt "\n\nü§ñ %s?" \
      "$(printf "%s" "${transl[common_prompt_are_you_sure_continue_y_or_n]}" | sed "s|_yes_|\"${transl[common_prompt_yes_as_y]}\"|g; s|_no_|\"${transl[common_prompt_no_as_n]}\"|g")"
    read -r -p "$prompt"$'\n> ' answer

    intlAnswer=$(mapLanguageYesNoQuitToSystem "$userSelectedLanguage" "$answer")

    if [[ "$intlAnswer" == [nN] || "$intlAnswer" == [nN][oO] ]]; then
      exitInstaller
    fi

    echo "üòÖ ${transl[check_sys_has_recommended_resources_warning_below_recommendation]}"

    sleep 5

    return 0
  fi
  
  showOkMessage "${transl[check_sys_has_recommended_resources_great_enought_resources]}"
}

checkIfGitInstalled() {
  if ! hasCommand git; then
    echo "üòÖ ${transl[check_if_git_installed_oops]}"
    echo

    requestAuthorizationAndExec \
      "${transl[common_check_installed_we_can_start_install]}" \
      "${transl[check_if_git_installed_need_git_installed]}" \
      installGit

    if [[ "$?" = 1 ]]; then
      showErrorMessage "${transl[check_if_git_installed_oops_failed_install]}"

      exitInstaller
    fi
  fi

  showOkMessage "${transl[check_if_git_installed_success_install]}"
}

gitHealthCheck() {
  if ! hasCommand git; then
    showErrorMessage "${transl[git_health_check_oops_odd_reason]}"

    exitInstaller
  fi
}

createDockerDaemonJsonForBuildKit() {
  sudo mkdir -p /etc/docker
  sudo bash -c 'echo "{
    \"features\": {
      \"buildkit\" : true
      }
    }" > /etc/docker/daemon.json'
}

installDocker() {
  os=$(identifyOS)

  if [[ "$os" == "linux" ]]; then
    distro=$(identifyDistro)

    if [[ "$distro" == "ubuntu" ]]; then
      sudo apt-get update
      sudo DEBIAN_FRONTEND=noninteractive apt-get install \
        ca-certificates \
        curl \
        gnupg \
        lsb-release \
        -yq

      sudo mkdir -p /etc/apt/keyrings
      curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

      echo \
        "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
        $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

      sudo apt-get update

      sudo DEBIAN_FRONTEND=noninteractive apt-get install \
          docker-ce \
          docker-ce-cli \
          containerd.io \
          docker-compose-plugin \
          -yq

      # https://docs.docker.com/build/buildkit/
      createDockerDaemonJsonForBuildKit
    elif [[ "$distro" == "debian" ]]; then
      sudo apt-get update
      sudo DEBIAN_FRONTEND=noninteractive apt-get install \
        ca-certificates \
        curl \
        gnupg \
        lsb-release \
        dnsutils \
        docker-compose-plugin \
        -yq

      sudo mkdir -p /etc/apt/keyrings
      curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

      echo \
        "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \
        $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

      sudo apt-get update

      sudo DEBIAN_FRONTEND=noninteractive apt-get install \
          docker-ce \
          docker-ce-cli \
          containerd.io \
          -yq

      # https://docs.docker.com/build/buildkit/
      sudo mkdir -p /etc/docker
      sudo bash -c 'echo "{
        \"features\": {
          \"buildkit\" : true
          }
        }" > /etc/docker/daemon.json'
    elif [[ "$distro" =~ "arch" ]]; then
      sudo pacman -Syu gnome-terminal docker docker-compose

      sudo systemctl enable docker.service

      latestKernel=$(pacman -Q linux)
      currentKernel=$(uname -r)

      if [[ "$latestKernel" != "$currentKernel" ]]; then
        echo "‚úã ${transl[install_docker_need_reboot]}"
        printf "%s" "${transl[install_docker_need_reboot_reason]}" | sed "s|_currentKernel_|\"${currentKernel}\"|g; s|_latestKernel_|${latestKernel}|g"
        echo
        echo "${transl[install_docker_need_reboot_if_failure]}"
        echo "${transl[install_docker_suggest_rebooting]}"
        echo

        read -rp "${transl[common_press_enter_continue]} "
      fi
    else
      printf -v common_oops_linux_distro_not_supported "%s" \
      "$(printf "%s" "${transl[common_oops_linux_distro_not_supported]}" | sed "s|_defaultGetFleekNetworkUrl_|\"${defaultGetFleekNetworkUrl}\"|g; s|_defaultFleekNetworkDocsWebsite_|${defaultFleekNetworkDocsWebsite}|g")"
      showErrorMessage "${common_oops_linux_distro_not_supported}"

      exitInstaller
    fi
  else
    printf -v common_oops_os_not_supported "%s" \
    "$(printf "%s" "${transl[common_oops_os_not_supported]}" | sed "s|_defaultFleekNetworkDocsWebsite_|\"${defaultFleekNetworkDocsWebsite}\"|g")"
    showErrorMessage "${common_oops_os_not_supported}"

    exitInstaller
  fi
}

checkIfDockerInstalled() {
  # TODO: docker-compose is going to be deprecated
  #¬†but before moving to `docker compose` as subcommand
  # is required to check the user docker version and also
  # check if docker compose is available. Some users are still
  # using legacy e.g., preinstalled docker or archlinux, etc
  if ! hasCommand docker; then
    printf "üòÖ %s\n" "${transl[check_if_docker_installed]}"

    requestAuthorizationAndExec \
      "${transl[common_check_installed_we_can_start_install]}" \
      "${transl[check_if_docker_need_docker_installed]}" \
      installDocker

    if [[ "$?" = 1 ]]; then
      showErrorMessage "${transl[check_if_docker_oops_failed_install_docker]}"

      exitInstaller
    fi
  else
    if [[ ! -f "$defaultDockerDaemonJson" ]]; then
      createDockerDaemonJsonForBuildKit
    else
      echo "ü§ñ Docker Buildkit require update in $defaultDockerDaemonJson"
      echo

      jqTmpDockerDaemonJsonFile="tmp.$dateRuntime"
      jq '.features.buildkit=true' "$defaultDockerDaemonJson" > "$jqTmpDockerDaemonJsonFile" && sudo mv "$jqTmpDockerDaemonJsonFile" "$defaultDockerDaemonJson" && cat "$defaultDockerDaemonJson"

      echo
    fi
  fi

  showOkMessage "${transl[check_if_docker_success]}"
}

requestPathnameForUrsaRepository() {
  # TODO: on translation, the selected path needs to be computed
  # that is that on runtime the defaultPath might need to be replaced
  # by the user selected choice, as we have these as precomputed text
  # TODO: close after test param expansion, see below
  selectedUrsaPath=$defaultUrsaPath

  printf -v prompt "\nü§ñ %s\n\n%s?\n%s" \
    "${transl[request_path_for_ursa_repo_save_to_location_use_default]/_selectedUrsaPath_/$selectedUrsaPath}" \
    "$(printf "%s" "${transl[request_path_for_ursa_repo_save_to_location_y_or_n_change]}" | sed "s|_yes_|\"${transl[common_prompt_yes_as_y]}\"|g; s|_no_|\"${transl[common_prompt_no_as_n]}\"|g")" \
    "${transl[request_path_for_ursa_repo_save_to_location_happy_proceed]}"
  
  while read -r -p "$prompt"$'\n> ' answer; do
    intlAnswer=$(mapLanguageYesNoQuitToSystem "$userSelectedLanguage" "$answer")
  
    if [[ "$intlAnswer" == "" || "$intlAnswer" == [yY] || "$intlAnswer" == [yY][eE][sS] || "$intlAnswer" == [nN] || "$intlAnswer" == [nN][oO] ]]; then
      break
    fi
  done

  if [[ ! "$intlAnswer" == "" && "$intlAnswer" == [nN] || "$intlAnswer" == [nN][oO] ]]; then
    printf -v prompt "\nüôã‚Äç‚ôÄÔ∏è %s" "${transl[request_path_for_ursa_repo_save_to_locattion_where_store]}"
    read -r -p "$prompt"$'\n> ' answer
  
    selectedUrsaPath="$answer"
  fi


  if [[ -d "$selectedUrsaPath" ]]; then
    # TODO: test param expansion
    showErrorMessage "${transl[request_path_for_ursa_repo_save_to_locattion_oops_already_exists]/_selectedUrsaPath_/$selectedUrsaPath}"

    read -r -p "${transl[common_press_enter_retry]}..."

    requestPathnameForUrsaRepository
  fi

  if ! sudo mkdir -p "$selectedUrsaPath"; then
    # TODO: test param expansion
    showErrorMessage "${transl[request_path_for_ursa_repo_save_to_oops_failed_create_dir]/_selectedUrsaPath_/$selectedUrsaPath}"

    exitInstaller
  fi

  echo "$selectedUrsaPath"
}

cloneUrsaRepositoryToPath() {
  if [[ -n ${URSA_BRANCH+x} ]]; then
    echo "ü•∑ Switch to branch $URSA_BRANCH"
    if ! sudo git clone -b "$URSA_BRANCH" "$defaultUrsaHttpsRepository" "$1"; then
      showErrorMessage \
        "$(printf "%s" "${transl[clone_ursa_repo_to_path_oops_failed_to_clone]}" | sed "s|_defaultUrsaHttpsRepository_|\"${defaultUrsaHttpsRepository}\"|g")"

      exitInstaller
    fi
  else
    if ! sudo git clone $defaultUrsaHttpsRepository "$1"; then
      showErrorMessage \
        "$(printf "%s" "${transl[clone_ursa_repo_to_path_oops_failed_to_clone]}" | sed "s|_defaultUrsaHttpsRepository_|\"${defaultUrsaHttpsRepository}\"|g")"

      exitInstaller
    fi
  fi

  showOkMessage \
    "$(printf "%s" "${transl[clone_ursa_repo_to_path_ok_msg]}" | sed "s|_defaultUrsaHttpsRepository_|\"${defaultUrsaHttpsRepository}\"|g; s|_selectedUrsaPath_|${1}|g")"

  printf "\r\n"
}

restartDockerStack() {
  echo "ü§ñ ${transl[restart_docker_stack_is_going_to_restart]}"
  echo

  dockerComposeExec -f "$defaultDockerComposeYmlRelativePath" stop

  showOkMessage "${transl[restart_docker_stack_is_going_to_start]}"

  dockerComposeExec -f "$defaultDockerComposeYmlRelativePath" up -d

  showOkMessage "${transl[restart_docker_stack_has_restarted]}"
}

showDockerStackLog() {
  echo
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ"
  echo
  echo "ü•≥ ${transl[show_docker_stack_log_great]}"
  echo
  echo "${transl[show_docker_stack_log_stack_should_be_running]}"
  echo
  echo "${transl[show_docker_stack_log_stack_logs_can_be_verbose_1_of_2]}"
  echo "${transl[show_docker_stack_log_stack_logs_can_be_verbose_2_of_2]}"
  echo "https://docs.fleek.network/guides/Network%20nodes/fleek-network-node-health-check-guide"
  echo
  echo "${transl[show_docker_stack_log_stack_logs_handy_commands]}"
  echo
  echo "  - ${transl[show_docker_stack_log_stack_logs_handy_cmd_show_logs]}:"
  echo
  echo "    ${txtPrefixForBold}docker compose -f ./docker/full-node/docker-compose.yml logs -f${txtPrefixForNormal}"
  echo
  echo "  - ${transl[show_docker_stack_log_stack_logs_handy_cmd_signit]}:"
  echo
  echo "    ${txtPrefixForBold}Ctrl-c${txtPrefixForNormal}"
  echo
  printf "%s" "${transl[show_docker_stack_log_stack_logs_can_stop_start_docker]}" | sed "s|_selectedUrsaPath_|\"${selectedUrsaPath}\"|g; s|_no_|\"${transl[common_prompt_no_as_n]}\"|g"
  echo "${transl[show_docker_stack_log_stack_logs_can_stop_start_docker_example]}"
  echo
  echo "${transl[show_docker_stack_log_stack_logs_can_stop_then_after_start_or_stop]}"
  echo
  echo "  - ${transl[show_docker_stack_log_stack_logs_can_stop_then_after_start]}"
  echo
  echo "    ${txtPrefixForBold}docker compose -f ./docker/full-node/docker-compose.yml up${txtPrefixForNormal}"
  echo
  echo "  - ${transl[show_docker_stack_log_stack_logs_can_stop_then_after_stop]}"
  echo
  echo "    ${txtPrefixForBold}docker compose -f ./docker/full-node/docker-compose.yml down${txtPrefixForNormal}"
  echo
  echo "ü•π ${transl[show_docker_stack_log_stack_logs_seems_a_lot]}"
  # The extra white space between ‚úèÔ∏è and start of text is intentional and used for alignment
  printf "ü§ì  %s" "${transl[show_docker_stack_log_stack_logs_learn_how_maintain]}" | sed "s|_defaultFleekNetworkDocsWebsite_|\"${defaultFleekNetworkDocsWebsite}\"|g"

  printf "üåà %s" "${transl[show_docker_stack_log_stack_logs_got_feedback]}" | sed "s|_defaultDiscordUrl_|\"${defaultDiscordUrl}\"|g; s|_defaultFleekNetworkTwitterUrl_|${defaultFleekNetworkTwitterUrl}|g"
  echo
  echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ"
  echo

  printf -v prompt "\nüôã‚Äç‚ôÄÔ∏è %s\n%s" \
    "${transl[show_docker_stack_log_stack_logs_prompt_see_output]}" \
    "$(printf "%s" "${transl[show_docker_stack_log_stack_logs_prompt_see_output_y_or_skip]}" | sed "s|_yes_|\"${transl[common_prompt_yes_as_y]}\"|g; s|_skip_|skip|g")"
  read -r -p "$prompt"$'\n> ' answer

  intlAnswer=$(mapLanguageYesNoQuitToSystem "$userSelectedLanguage" "$answer")

  if [[ "$intlAnswer" == [sS][kK][iI][pP] ]]; then
    printf "\r\n"

    echo "üöÄ ${transl[show_docker_stack_log_stack_logs_completed_process_thanks]}"
    printf "ü§ó %s" "${transl[show_docker_stack_log_stack_logs_completed_process_remember]}" | sed "s|_defaultFleekNetworkWebsite_|\"${defaultFleekNetworkWebsite}\"|g"

    echo

    onExitInstallerTodos
    
    exit 0;
  fi

  # whitespace to improve   
  printf "\r\n"
  
  echo "üëã ${transl[show_docker_stack_log_stack_logs_quick_hint]}!"
  echo
  echo "${transl[show_docker_stack_log_stack_logs_stack_logs_verbose]}"
  echo
  echo "${transl[show_docker_stack_log_stack_logs_stack_keeps_awake_discord]}"
  echo
  echo "${transl[show_docker_stack_log_stack_logs_about_log_messages_ignore]}"

  read -r -p "${transl[common_press_enter_continue]}... "

  dockerComposeExec -f "$defaultDockerComposeYmlRelativePath" logs -f
}

ursaServerConfigurationHandler() {
  if [[ ! -d "$defaultUrsaProxyDir" ]]; then
    #¬†TODO: Create translation
    echo "‚úÖ Create Ursa proxy directory"
    sudo mkdir -p "$defaultUrsaProxyDir"
    sudo touch "$defaultUrsaProxyConfigPath"
  fi

  if [[ ! -f "$defaultUrsaProxyConfigPath" ]]; then
    sudo touch "$defaultUrsaProxyConfigPath"
  fi

# Here "no identation" is intentional, do not change
# The top empty line at the top is intentional
echo "# Server without TLS.
[[server]]
proxy_pass = \"$defaultDockerNetworkUrsaHostname:4069\"
listen_addr = \"0.0.0.0:80\"
serve_dir_path = \".well-known\"

# Server with TLS
[[server]]
proxy_pass = \"$defaultDockerNetworkUrsaHostname:4069\"
listen_addr = \"0.0.0.0:443\"

[server.tls]
cert_path = \"$defaultLetsEncryptCertificatesLivePath/$userDomainName/fullchain.pem\"
key_path = \"$defaultLetsEncryptCertificatesLivePath/$userDomainName/privkey.pem\"

# Admin service.
# You can omit this section as this is the default.
[admin]
addr = \"0.0.0.0:8881\"
" | sudo tee "$defaultUrsaProxyConfigPath" || exit 1

  #¬†TODO: Create translation
  echo "‚úÖ Updated the config.toml by including the [server] settings"
  echo
}

initLetsEncrypt() {
  email="$1"
  domain="$2"

  if [[ -z "$1" || -z "$2" ]]; then
    showErrorMessage "${transl[init_lets_encrypt_gosh_embarrassing_missing_args]} üôè"

    exitInstaller
  fi

  # Ursa server configuration handler to ensure the settings exist and correct
  ursaServerConfigurationHandler

  if [[ ! -f "$defaultUrsaProxyConfigPath" ]]; then
    #¬†TODO: Create translation
    echo "üí© Uh oh! This is embarrassing, but we tried to create $defaultUrsaProxyConfigPath but is missing for some reason..."
    echo
  fi

  if ! dockerComposeExec -f "$defaultDockerComposeYmlRelativePath" run \
      -p 80:80 \
      --rm --entrypoint "\
      certbot certonly \
        --standalone \
        --preferred-challenges http \
        --email $email \
        --domain $domain \
        --rsa-key-size 4096 \
        --agree-tos -n" certbot; then
    #¬†TODO: Create translation
    echo "üëπ Oops! Failed to create the certificate"
    echo
    echo "üí° If you already had Certbot installed, make sure you update to latest before retrying please"

    exit 1
  else
    #¬†TODO: Create translation
    echo "‚úÖ Certbot process completed"
  fi

  showOkMessage "${transl[init_lets_encrypt_success_secured_message]}"
}

installMandatory() {
  hasCommand "$1" && return 0

  printf -v prompt "\n\nü§ñ %s\n%s" \
    "$(printf "%s" "${transl[common_install_we_need_to]}" | sed "s|_application_|\"${1}\"|g; s|_yes_|\"${transl[common_prompt_yes_as_y]}\"|g; s|_no_|\"${transl[common_prompt_no_as_n]}\"|g")" \
    "$(printf "%s" "${transl[common_install_type_y_or_n]}" | sed "s|_yes_|\"${transl[common_prompt_yes_as_y]}\"|g; s|_no_|\"${transl[common_prompt_no_as_n]}\"|g")"
  while read -rp "$prompt"$'\n> ' answer; do
    data=$(confirm "$userSelectedLanguage" "$answer")

    [[ ! $data ]] && continue

    if [[ "$data" -eq 1 ]]; then
      showErrorMessage "${transl[install_mandatory_app_install_required]/_application_/$1}"
      exitInstaller
    elif [[ "$data" -eq 0 ]]; then
      break
    fi
  done

  if [[ "$os" == "linux" ]]; then
    distro=$(identifyDistro)
    if [[ "$distro" == "ubuntu" ]] || [[ "$distro" == "debian" ]]; then
      if ! sudo apt update || ! sudo DEBIAN_FRONTEND=noninteractive apt-get install "$1" -yq; then
        exitInstaller
      fi
    elif [[ "$distro" =~ "arch"  ]]; then
      ! sudo pacman -Syu "$1" && exitInstaller
    else
      echo "üëπ ${transl[install_mandatory_distro_not_supported]/_distro_/$distro}"
      echo "${transl[install_mandatory_if_bug_discord]} üôè"
      echo

      exitInstaller
    fi
  fi

  showOkMessage "${transl[install_mandatory_installed]} $1"

  # Add some space after the msg
  printf "\r\n"

  return 0
}

verifyDepsOrInstall() {
  os="$1"
  name="$2"
  bin="$3"
  pkgManager="$4"

  hasCommand "$bin" && return 0

  printf -v prompt "\n\nü§ñ %s\n%s" \
    "$(printf "%s" "${transl[common_install_we_need_to]}" | sed "s|_application_|\"${bin}\"|g; s|_yes_|\"${transl[common_prompt_yes_as_y]}\"|g; s|_no_|\"${transl[common_prompt_no_as_n]}\"|g")" \
    "$(printf "%s" "${transl[common_install_type_y_or_n]}" | sed "s|_yes_|\"${transl[common_prompt_yes_as_y]}\"|g; s|_no_|\"${transl[common_prompt_no_as_n]}\"|g")"
  while read -rp "$prompt"$'\n> ' answer; do
    data=$(confirm "$userSelectedLanguage" "$answer")

    [[ ! $data ]] && continue

    if [[ "$data" -eq 1 ]]; then
      showErrorMessage "${transl[install_mandatory_app_install_required]/_application_/$1}"
      exitInstaller
    elif [[ "$data" -eq 0 ]]; then
      break
    fi
  done

  if [[ "$ans" == "" ]]; then
    echo "üòÖ ${transl[verify_deps_installed_need_yes_or_no_answer]}"
    
    read -r -p "${transl[common_press_enter_retry]}..."

    verifyDepsOrInstall "$os" "$name" "$bin" "$pkgManager"
  fi

  if [[ "$os" == "linux" ]]; then
    distro=$(identifyDistro)
    pkgManager=$(echo "$pkgManager" | jq ".$distro")
    pkgManagerName=$(echo "$pkgManager" | jq -r ".name")
    pkg=$(echo "$pkgManager" | jq -r ".pkg")

    if [[ $pkgManager =~ "null" || $pkgManagerName =~ "null" || $pkg =~ "null" ]]; then
      echo "üí© ${transl[verify_deps_installed_config_has_missing_values]}"
      echo "LOG: pkgm ($pkgManager), pkgmn ($pkgManagerName), pkg ($pkg)"
      echo
      printf "%s" "${transl[verify_deps_installed_help_us_improve_discord]}" | sed "s|_defaultDiscordUrl_|\"${defaultDiscordUrl}\"|g"

      echo "${transl[verify_deps_installed_thanks_support]} üôè"
      echo

      exitInstaller
    fi

    if [[ "$distro" == "ubuntu" || "$distro" == "debian" ]]; then
      if [[ $pkgManagerName == "snap" ]]; then
        if ! hasCommand "snap"; then
          sudo DEBIAN_FRONTEND=noninteractive apt-get install snapd -yq
        fi

        if ! sudo snap install "$pkg"; then
          exitInstaller
        fi

        showOkMessage "${transl[verify_deps_installed_via_package_manager]/_name_/$name} snap"

        # ensure snap is in the PATH and pkgs
        export PATH="$PATH:/snap/bin"

        return 0
      fi

      if ! sudo apt update || ! sudo DEBIAN_FRONTEND=noninteractive apt-get install "$pkg" -yq; then
        exitInstaller
      fi

      showOkMessage "${transl[verify_deps_installed_via_package_manager]/_name_/$name} apt-get"

      return 0
    elif [[ "$distro" =~ "arch"  ]]; then
      if [[ $pkgManagerName == "pip" ]]; then
        if ! hasCommand pip; then 
          sudo pacman --noconfirm -Syu python-pip
        fi

        pip install tldextract==3.4.0

        return 0
      fi

      ! sudo pacman --noconfirm -Syu "$pkg" && exitInstaller

      showOkMessage "${transl[verify_deps_installed_via_package_manager]/_name_/$name} pacman"
    fi
  fi
}

extactDomainName() {
  name=$(tldextract "$1" | cut -d " " -f 2)
  tld=$(tldextract "$1" | cut -d " " -f 3)

  domain="$name.$tld"

  echo "$domain"
}

verifyUserHasDomain() {
  printf -v prompt "\n%s?\n%s" \
    "$(printf "%s" "${transl[verify_user_has_domain_have_domain_ready]}" | sed "s|_yes_|\"${transl[common_prompt_yes_as_y]}\"|g; s|_no_|\"${transl[common_prompt_no_as_n]}\"|g")" \
    "$(printf "%s" "${transl[verify_user_has_domain_have_domain_ready_yes_or_n_or_q]}" | sed "s|_yes_|\"${transl[common_prompt_yes_as_y]}\"|g; s|_no_|\"${transl[common_prompt_no_as_n]}\"|g; s|_quit_|\"${transl[common_prompt_quit_as_q]}\"|g")"
  read -r -p "$prompt"$'\n> ' ans

  intlAnswer=$(mapLanguageYesNoQuitToSystem "$userSelectedLanguage" "$ans")

  if [[ "$intlAnswer" == [qQ] ]]; then
    showErrorMessage \
      "$(printf "ü¶ñ %s" "${transl[verify_user_has_domain_user_quit_message]}" | sed "s|_defaultFleekNetworkDocsWebsite_|\"${defaultFleekNetworkDocsWebsite}\"|g")"

    exit 1
  fi

  if [[ ! "$intlAnswer" == "" && "$intlAnswer" == [nN] || "$intlAnswer" == [nN][oO] ]]; then
    printf "\n"

    showErrorMessage "${transl[verify_user_has_domain_oops_best_have_domain]}"

    read -r -p "${transl[common_press_enter_retry]}..."

    verifyUserHasDomain
  fi

  # Domain name handling (start)
  printf -v prompt "\nüí° %s\n\n%s" "${transl[verify_user_has_domain_provide_domain_without_http_1_of_2]}" "${transl[verify_user_has_domain_provide_domain_without_http_2_of_2]}"
  while read -rp "$prompt"$'\n> ' ans; do
    if confirmDomainName "$ans"; then
      userDomainName="$ans"
      break
    fi

    showPoopMessage "${transl[verify_user_has_domain_uh_oh_provide_valid_domain]}..."
  done

  # Ip address handling (start)
  ERROR_IP_ADDRESS_NOT_AVAILABLE="ERROR_IP_ADDRESS_NOT_AVAILABLE"
  detectedIpAddress=$(curl --silent ifconfig.me || curl --silent icanhazip.com || echo "$ERROR_IP_ADDRESS_NOT_AVAILABLE")

  printf -v prompt "\nüí° %s\n\n%s\n\n%s" "${transl[verify_user_has_domain_provide_ip_of_machine_1_of_3]/_detectedIpAddress_/$detectedIpAddress}" "${transl[verify_user_has_domain_provide_ip_of_machine_2_of_3]}" "${transl[verify_user_has_domain_provide_ip_of_machine_3_of_3]}"
  while read -rp "$prompt"$'\n> ' ans; do
    if confirmIpAddress "$ans"; then
      serverIpAddress="$ans"
      break
    elif [[ "$ans" == "" ]]; then
      break
    fi

    showPoopMessage "${transl[verify_user_has_domain_uh_oh_provide_valid_ip]}..."
  done

  # Declare detected ip address as default server ip address
  serverIpAddress=${ans:="$detectedIpAddress"}

  if [[ $serverIpAddress = "$ERROR_IP_ADDRESS_NOT_AVAILABLE" ]]; then
    showErrorMessage "${transl[verify_user_has_domain_oops_embarassing]/_ERROR_IP_ADDRESS_NOT_AVAILABLE_/$ERROR_IP_ADDRESS_NOT_AVAILABLE}"

    exitInstaller
  fi

  # given a name and an ip address, test whether there is a record for name pointing to address
  if ! dig "$userDomainName" +nostats +nocomments +nocmd | tr -d '\t' | grep "A$serverIpAddress" >/dev/null 2>&1 ; then
    showErrorMessage "${transl[verify_user_has_domain_oops_domain_no_dns_record_correct_ip_1_of_2]/_userDomainName_/$userDomainName} ${transl[verify_user_has_domain_oops_domain_no_dns_record_correct_ip_2_of_2]/_serverIpAddress_/$serverIpAddress}"

    read -r -p "${transl[common_press_enter_retry]}..."

    verifyUserHasDomain
  fi

  # Email handling (start)
  printf -v prompt "üí° %s\n%s\n\n%s\n%s\n\n%s" "${transl[verify_user_has_domain_provide_valid_email_1_of_5]}" "${transl[verify_user_has_domain_provide_valid_email_2_of_5]}" "${transl[verify_user_has_domain_provide_valid_email_3_of_5]}" "${transl[verify_user_has_domain_provide_valid_email_4_of_5]}" "${transl[verify_user_has_domain_provide_valid_email_5_of_5]}"
  while read -rp "$prompt"$'\n> ' ans; do
    if confirmEmailAddress "$ans"; then
      emailAddress=$(toLowerCase "$ans")
      break
    fi

    showPoopMessage "${transl[verify_user_has_domain_uh_oh_provide_valid_email]}..."
  done

  printf -v prompt "\nü§ñ %s\n\n%s\n%s\n%s\n\n%s\n%s" \
    "${transl[verify_user_has_domain_details_confirmation_1_of_6]}" \
    "${transl[verify_user_has_domain_details_confirmation_2_of_6]/_userDomainName_/$userDomainName}" \
    "${transl[verify_user_has_domain_details_confirmation_3_of_6]/_serverIpAddress_/$serverIpAddress}" \
    "${transl[verify_user_has_domain_details_confirmation_4_of_6]/_emailAddress_/$emailAddress}" \
    "$(printf "%s" "${transl[verify_user_has_domain_details_confirmation_5_of_6]}" | sed "s|_yes_|\"${transl[common_prompt_yes_as_y]}\"|g; s|_no_|\"${transl[common_prompt_no_as_n]}\"|g")" \
    "$(printf "%s" "${transl[verify_user_has_domain_details_confirmation_6_of_6]}" | sed "s|_yes_|\"${transl[common_prompt_yes_as_y]}\"|g; s|_no_|\"${transl[common_prompt_no_as_n]}\"|g")"

  while read -rp "$prompt"$'\n> ' ans; do
    intlAnswer=$(mapLanguageYesNoQuitToSystem "$userSelectedLanguage" "$ans")

    case $intlAnswer in
      [yY])
        break
        ;;
      [yY][eE][sS])
        break
        ;;
      [nN])
        verifyUserHasDomain
        break
        ;;
      [nN][oO])
        verifyUserHasDomain
        break
        ;;
    esac;
  done;

  echo "$userDomainName;$emailAddress;$serverIpAddress"
}

setupSSLTLS() {
  echo "‚ö†Ô∏è ${transl[setup_ssl_tls_you_are_required]}"
  echo
  echo "${transl[setup_ssl_tls_visit_your_domain_name_registrar]}"
  echo
  # The extra white space between the ü´° and text is intentional for spacing
  echo "ü´°  ${transl[setup_ssl_tls_complete_step_before_proceeding]}"
  echo "${transl[setup_ssl_tls_reason_to_secure_server]}"
  echo
  echo "üôè ${transl[setup_ssl_tls_learn_more_about]}"
  printf "\n"

  trimData=$(verifyUserHasDomain | xargs)

  if [[ ! "$trimData" ]]; then
    showErrorMessage "ü¶ñ ${transl[setup_ssl_tls_failed_verify_user_domain_and_email]}..."

    exit 1
  fi

  userDomainName=$(echo "$trimData" | cut -d ";" -f 1)
  emailAddress=$(echo "$trimData" | cut -d ";" -f 2)
  serverIpAddress=$(echo "$trimData" | cut -d ";" -f 3)

  if ! initLetsEncrypt "$emailAddress" "$userDomainName"; then
    exitInstaller
  fi

  #¬†TODO: Create translation
  echo "ü§ñ Set Ursa proxy configuration for SSL/TLS"
  if ! dockerComposeExec -f "$defaultDockerComposeYmlRelativePath" run \
    --rm --entrypoint "\
    if ! curl -X POST 0.0.0.0:8881/reload-tls-config; then
      exit 1;
    fi
    " "$defaultDockerNetworkUrsaProxyHostname"; then
    echo "üí© Uh oh! Failed to reload the ursa-proxy TLS configuration."
    echo

    sleep 3
  fi

  if [[ ! -f "$defaultUrsaProxyConfigPath" ]]; then
    #¬†TODO: Create translation
    echo "üí© Uh oh! We tried to modify $defaultUrsaProxyConfigPath but is missing."
    echo
  fi

  restartDockerStack
}

changeDirectoryToPathOrFailure() {
  local name=$1
  local targetPath=$2

  if [[ -z "$name" || -z "$targetPath" ]]; then
    showErrorMessage "${transl[change_directory_to_path_oops_failed_change_dir_discord]} üôè"

    exitInstaller
  fi

  if [[ $(pwd) != "$targetPath" ]]; then
    if ! cd "$targetPath"; then
      showErrorMessage "${transl[change_directory_to_path_oops_failed_change_dir_to_name]/_name_/$name} üôè"

      exitInstaller
    fi
  fi
}

onLatestPreference() {
  echo
  echo "‚úã ${transl[on_latest_preference_when_running_stack_docker_build]}"
  echo "üí° ${transl[on_latest_preference_our_recommendation]} üò¥!"
  echo
  echo "${transl[on_latest_preference_inf_future_check_documentation]}"
  echo

  printf -v prompt "\n\nü§ñ %s\n%s" \
    "$(printf "%s" "${transl[on_latest_preference_prompt_happy_use_latest]}" | sed "s|_yes_|\"${transl[common_prompt_yes_as_y]}\"|g; s|_no_|\"${transl[common_prompt_no_as_n]}\"|g")" \
    "$(printf "%s" "${transl[on_latest_preference_prompt_happy_use_latest_yes_or_no]}" | sed "s|_yes_|\"${transl[common_prompt_yes_as_y]}\"|g; s|_no_|\"${transl[common_prompt_no_as_n]}\"|g")"
  while read -rp "$prompt"$'\n> ' ans; do
    data=$(confirm "$userSelectedLanguage" "$ans")

    [[ ! $data ]] && continue

    if [[ "$data" -eq 1 ]]; then
      echo
      echo "ü¶Ä ${transl[on_latest_preference_mind_ursa_time_build_long]}..."
      echo

      break
    elif [[ "$data" -eq 0 ]]; then
      for name in "ursa" "ursa-proxy"; do
        if ! yqExec -ie "del(.services.$name.build)" "$defaultDockerComposeYmlRelativePath" >/dev/null 2>&1; then
          echo "üëπ Oops! Failed to remove declare service build $name from $defaultDockerComposeYmlRelativePath"
        else
          echo "‚úÖ Deleted docker-compose.yml .services.$name.build"
        fi

        currentImageName="${defaultGHCRImagePlaceholderUrl/_imageName_/$name}"

        if ! yqExec -i ".services.$name.image = \"$currentImageName\"" "$defaultDockerComposeYmlRelativePath" >/dev/null 2>&1; then
          echo "üëπ Oops! Failed to set service $name image in $defaultDockerComposeYmlRelativePath"
        else
          echo "‚úÖ Set service in docker-compose.yml .services.$name.image"
        fi

        if ! yqExec ".services.$name.image" "$defaultDockerComposeYmlRelativePath" | grep -q "$currentImageName" || ! yqExec ".services.$name.build" "$defaultDockerComposeYmlRelativePath" | grep -qE "null|no matches found"; then
          echo
          echo "üí© ${transl[on_latest_preference_uh_oh_failed_modify_docker_compose_yaml]}"

          printf "%s üôè" "${transl[on_latest_preference_uh_oh_failed_modify_docker_compose_yaml_apologies]}" | sed "s|_defaultDiscordUrl_|\"${defaultDiscordUrl}\"|g"
          echo

          exitInstaller
        fi
      done

      break
    fi
  done
}

updateUrsaConfigIpAddress() {
  if [[ -f "$defaultUrsaConfigPath" ]]; then
    if ! sudo sed -i "s|addresses =.*|addresses = [\"/ip4/$serverIpAddress/tcp/80\"]|" "$defaultUrsaConfigPath"; then
      showPoopMessage "${transl[on_update_ursa_config_ip_address_update_error]/_serverIpAddress_/$serverIpAddress}"
    fi
  else
    if ! sudo mkdir -p "$defaultUrsaBasePath"; then
      showPoopMessage "${transl[on_update_ursa_config_ip_address_update_error]/_serverIpAddress_/$serverIpAddress}"
    fi

    if ! createUrsaInitialConfig; then
      showPoopMessage "${transl[on_update_ursa_config_ip_address_update_error]/_serverIpAddress_/$serverIpAddress}"
    fi
  fi
}

createUrsaInitialConfig() {
  if ! sudo touch "$defaultUrsaConfigPath"; then
    return 1
  fi

  echo "[server_config]" | sudo tee "$defaultUrsaConfigPath"
  echo "addresses = [\"/ip4/$serverIpAddress/tcp/80\"]" | sudo tee -a "$defaultUrsaConfigPath"
  echo
}

(
  # stdin to keyboard
  exec < /dev/tty;

  # SIGINT listener
  trap onInterruption INT

  # Set default locale
  multiLanguageChoice

  # Identity the OS
  os=$(identifyOS)

  # TODO: bug found this should be the distro
  isOSSupported "$os"

  # Show disclaimer
  showDisclaimer

  # Had space after disclaimer
  printf "\r\n"

  # Check if system has recommended resources (disk space and memory)
  checkSystemHasRecommendedResources "$os"

  echo
  
  # Warning for none root users
  if [ "$(id -u)" -ne 0 ]; then
    if test -z "$(sudo -n -v 2>&1)"; then
      #¬†TODO: Create translation
      echo "üëª You're running the installer as a non-root user. The installer will use sudo througout the process, meaning that the Ursa configuration and sensitive data files will be stored under /root/.ursa, e.g. /root/.ursa/keystore/default.pem"
      echo
      echo "If you'd like to customise it, learn more to manage file permissions read our guide \"Securing the Ursa files\" https://docs.fleek.network/guides/Network%20nodes/securing-the-ursa-files"
      echo
      read -rp "Keep a note on that and when happy press ENTER to continue..."
    else
      #¬†TODO: Create translation
      echo "üëπ Ooops! You're running the installer as a non-root user or non-sudoer. You need administrative rights to run the install process! Change to a root or sudoer user before retrying, please!"

      exit 1
    fi
  fi

  # Check if has dependencies installed
  for dep in "${dependencies[@]}"; do
    installMandatory "$dep"
  done

  for dep in $(echo "${config}" | jq -r '.dependencies[] | @base64'); do
    name=$(getJQPropertyValue "$dep" ".name")
    bin=$(getJQPropertyValue "$dep" ".bin")
    pkgManager=$(getJQPropertyValue "$dep" ".pkgManager")

    verifyDepsOrInstall "$os" "$name" "$bin" "$pkgManager"
  done

  # We start by verifying if git is installed, if not request to install
  checkIfGitInstalled "$os"

  gitHealthCheck

  # Verify if Docker is installed, if not install it
  checkIfDockerInstalled "$os"

  # Request a pathname where to store the Ursa repository, otherwise provide a default
  selectedUrsaPath=$(requestPathnameForUrsaRepository)

  # Check if directory does not exit or empty
  if [[ "$(ls -A "$selectedUrsaPath" >/dev/null 2>&1)" ]]; then
    echo
    echo "üòÖ ${transl[on_latest_preference_have_run_install_before_surprise]}"
    echo
    echo "${transl[on_latest_preference_directory_not_empty]/_selectedUrsaPath_/$selectedUrsaPath}"
    echo "${transl[on_latest_preference_if_stuck_clear_location_1_of_2]}"
    echo "${transl[on_latest_preference_if_stuck_clear_location_2_of_2]/_defaultUrsaPath_/$defaultUrsaPath}"

    exitInstaller
  fi

  # Pull the `ursa` project repository to the preferred target directory via HTTPS
  cloneUrsaRepositoryToPath "$selectedUrsaPath"
  changeDirectoryToPathOrFailure "Ursa" "$selectedUrsaPath"
  
  #¬†TODO: Create translation
  echo "ü§ñ Restart docker for Docker daemon settings to take effect"
  sudo systemctl restart docker

  #¬†Await a few seconds to let the user read...
  sleep 5

  # Recommend the Latest build to speed up onboarding
  onLatestPreference

  # Add some space after the "latest" request
  printf "\r\n"

  # Optional, check if user would like to setup SSL/TLS
  setupSSLTLS

  showOkMessage "${transl[on_latest_preference_success_install_completed]}"

  # Add some space after the "complete" message
  printf "\r\n"
  
  #¬†Await a few seconds to let the user read...
  sleep 5

  # The Ursa config has an ip address property
  # which value is shared to the indexer
  updateUrsaConfigIpAddress

  # Restart docker
  restartDockerStack

  # Set installation has complet
  installationStatus="$statusComplete"

  # Add some space after the "docker stack restart" message
  printf "\r\n"

  # Show the logs
  showDockerStackLog
  
  resetStyles
  exit;
)