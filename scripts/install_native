#!/bin/bash

# <!-- IGNORE: This line is intentional DO NOT MODIFY --><pre><script>document.querySelector('body').firstChild.textContent = '#!/bin/bash'</script>

# "Get Fleek Network" is an attempt to make our software more accessible.
# By providing scripts to automate the installation process of our software,
# we believe that it can help improve the onboarding experience of our users.
#
# Quick install: `curl https://get.fleek.network| bash`
#
# This script automates the process illustrated in our guide "how to install rust and the dependencies for ursa cli"
# advanced users might find it better to follow the instructions in the guide
# If that's your preference, go ahead and check our guides https://docs.fleek.network
#
# For the users happy to have the script assist in the installation process of Fleek Network
# and the required dependencies, run the script at your own risk. 
#
# Contributing?
# - If you'd like to test changes locally use the env var `USE_BRANCH_NAME_FOR_GH_RAW`, for remote locales pulls
#
# Found an issue? Please report it here: https://github.com/fleek-network/get.fleek.network

# üöë Check if running in Bash and supported version
[ "$BASH" ] || { printf >&2 'üôè Run the script with Bash, please!\n'; exit 1; }
(( BASH_VERSINFO[0] > 4 || BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] >= 2 )) || { printf >&2 'üôè Bash 4.2 or newer is required!\n'; exit 1; }

# üöë Check total Processing Units
vCPUs=$(nproc --all)
if [[ "$vCPUs" -lt 4 ]]; then
  while read -rp "üòÖ The installer needs at least 4 total processing units, your system has $vCPUs. The installer is likely to fail, would you like to continue? (yes/no)" answer; do
    if [[ "$answer" == [nN] || "$answer" == [nN][oO] ]]; then
      printf "ü¶ñ Exited the installation process\n\n"

      exit 1
    elif [[ "$answer" == [yY] || "$answer" == [yY][eE][sS] ]]; then
      printf "üòÖ Good luck!\n\n"

      break;
    fi

    printf "üí© Uh-oh! We expect a yes or no answer. Try again...\n"
  done
fi

# üöë Check memory
defaultMinMemoryKBytesRequired=8000000
defaultMinDiskSpaceKBytesRequired=1000000
mem=$(awk '/^MemTotal:/{print $2}' /proc/meminfo);
partDiskSpace=$(df --output=avail -B 1 "$PWD" |tail -n 1)

if [[ ("$mem" -lt "$defaultMinMemoryKBytesRequired") ]] || [[ ( "$partDiskSpace" -lt "$defaultMinDiskSpaceKBytesRequired" ) ]]; then
  echo "üí© Uh oh! We're afraid you need at least 8 GB of RAM and 10 GB of available disk space"

  read -r -p "Are you sure you want to continue? (yes/no)" answer

  if [[ "$answer" == [nN] || "$answer" == [nN][oO] ]]; then
    printf "ü¶ñ Exited the installation process\n"

    exit 1
  fi
fi

#¬†üöë Check if ports available
declare -a requiredPorts=(80 443 4069 6009)

if ! dpkg -s lsof >/dev/null; then
  sudo DEBIAN_FRONTEND=noninteractive apt-get install lsof -y
fi

hasPortsAvailable=0
for port in "${requiredPorts[@]}"; do
  if lsof -i :"$port" >/dev/null; then
    printf "üí© Uh-oh! The port %s is required but is in use...\n" "$port"

    hasPortsAvailable=1
  fi
done

if [[ "$hasPortsAvailable" -eq 1 ]]; then
  printf "üëπ Oops! Required port(s) are in use, make sure the ports are open before retrying, please!\n"

  exit 1
fi

if [ "$(id -u)" -ne 0 ]; then
  printf "üòÖ Our apologies! You need to run as root. We should provide support for sudoers shortly üôè\n" >&2;

  exit 1;
fi

# Date
dateRuntime=$(date '+%Y%m%d%H%M%S')

# Defaults
defaultUrsaPath="$HOME/fleek-network/ursa"
defaultNginxSitesAvailablePath="/etc/nginx/sites-available"
defaultNginxSitesEnabledPath="/etc/nginx/sites-enabled"
defaultUrsaNginxHttpConfFilename="ursa-http.conf"
defaultUrsaNginxHttpsConfFilename="ursa-https.conf"
defaultACMEChallengeMsgPlaceholder="_domain_ ACME Challenge directory is healthy!"
defaultLetsEncryptOptionsSSLNginxConf="/etc/letsencrypt/options-ssl-nginx.conf"
defaultLetsEncryptSSLDHParams="/etc/letsencrypt/ssl-dhparams.pem"
defaultUrsaLogPath="/var/log/ursa"
defaultUrsaDiagnosticFilename="diagnostic.log"
defaultUrsaOutputFilename="output.log"
defaultUrsaDiagnosticLogAbsPath="$defaultUrsaLogPath/$defaultUrsaDiagnosticFilename"
defaultUrsaOutputLogAbsPath="$defaultUrsaLogPath/$defaultUrsaOutputFilename"
defaultUrsaSystemdServiceName="ursa"
defaultUrsaSystemdServicePath="/etc/systemd/system/$defaultUrsaSystemdServiceName.service"
defaultUrsaConfigFilename="config.toml"
defaultUrsaBasePath="$HOME/.ursa"
defaultUrsaConfigPath="$defaultUrsaBasePath/$defaultUrsaConfigFilename"
defaultUrsaConfigBackupPath="$defaultUrsaConfigPath.backup.$dateRuntime"

# App state
selectedUrsaPath="$defaultUrsaPath"
selectedDomainName=""
selectedIpAddress=""
selectedEmailAddress=""
selectedNginxSitesAvailablePath=""
selectedNginxSitesEnabledPath=""
vCPUsMinusOne=$(($vCPUs - 1))

# Confirm validators
confirmDomainName() {
  local validate="^([a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]\.)+[a-zA-Z]{2,}$"

  if ! hasCommand whois; then
    sudo DEBIAN_FRONTEND=noninteractive apt-get install whois -yq
  fi

  if whois "$1" | grep -Ei '[Uu]nallocated|returned 0 objects' > /dev/null; then
    return 1
  fi

  [[ $1 =~ $validate ]]
}

validateIpAddress() {
  local validate="^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$"

  [[ "$1" =~ $validate ]] && ping -c1 -W1 "$1" > /dev/null
}

confirmEmailAddress() {
  local validate="^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]+$"

  [[ "$1" =~ $validate ]]
}

hasCommand() {
  command -v "$1" >/dev/null 2>&1
}

initCertbot() {
  domain="$1"
  email="$2"

  if ! hasCommand snap; then
    printf "ü§ñ Install Snap package manager\n"
    sudo DEBIAN_FRONTEND=noninteractive apt-get install snapd -yq
  else
    printf "ü§ñ Ensure that your version of snapd is up to date\n"
    sudo snap install core
    sudo snap refresh core
  fi

  echo

  printf "ü§ñ Remove certbot-auto and any Certbot OS packages\n"
  sudo DEBIAN_FRONTEND=noninteractive apt-get remove certbot

  echo

  printf "ü§ñ Install certbot\n"
  sudo snap install --classic certbot

  echo

  printf "ü§ñ Prepare the Certbot command\n"
  sudo ln -s /snap/bin/certbot /usr/bin/certbot

  echo

  printf "ü§ñ Get and install your certificates\n"
  sudo certbot certonly \
    --webroot -w /var/www/"$selectedDomainName" \
    --email "$email" \
    --domain "$domain" \
    --rsa-key-size 4096 \
    --agree-tos -n \
    --force-renewal \
    -v

  echo

  printf "ü§ñ Test automatic renewal\n"
  sudo certbot renew --dry-run

  echo

  printf "ü§ñ Health check\n"
}

identifyOS() {
  unameOut="$(uname -s)"

  case "${unameOut}" in
      Linux*)     os=Linux;;
      Darwin*)    os=Mac;;
      CYGWIN*)    os=Cygwin;;
      MINGW*)     os=MinGw;;
      *)          os="UNKNOWN:${unameOut}"
  esac

  echo "$os" | tr '[:upper:]' '[:lower:]'
}

identifyDistro() {
  if [[ -f /etc/os-release ]]; then
    source /etc/os-release
    echo "$ID"

    exit 0
  fi
  
  uname
}

isOSSupported() {
  os=$(identifyOS)

  if [[ "$os" == "linux" ]]; then
    distro=$(identifyDistro)

    if [[ "$distro" == "ubuntu" ]]; then
      currVersion=$(lsb_release -r -s | tr -d '.')

      if [[ "$currVersion" -lt "2204" ]]; then
        echo
        echo "üëπ Oops! You'll need Ubuntu 22.04 at least"
        echo

        exit 1
      fi
    elif [[ "$distro" == "debian" ]]; then
      currVersion=$(lsb_release -r -s | tr -d '.')

      if [[ "$currVersion" -lt "11" ]]; then
        echo
        echo "üëπ Oops! You'll need Debian 11 at least"
        echo

        exit 1
      fi
    else
      printf "üëπ Oops! Your operating system (%) distro (%s) is not supported by the installer at this time. Check our guides to learn how to install on your own https://docs.fleek.network\n" "$os" "$distro"

      exit 1    
    fi

    echo "‚úÖ Operating system ($os), distro ($distro) is supported!"
  else
    printf "üëπ Oops! Your operating system (%) is not supported by the installer at this time. Check our guides to learn how to install on your own https://docs.fleek.network\n" "$os"

    exit 1
  fi
}

getIpAddress() {
  detectedIpAddress=$(curl -s ifconfig.me)

  if validateIpAddress "$detectedIpAddress"; then
    echo "$detectedIpAddress"

    return
  fi

  detectedIpAddress=$(curl -s icanhazip.com)

  if validateIpAddress "$detectedIpAddress"; then
    echo "$detectedIpAddress"

    return
  fi

  detectedIpAddress=$(curl -s ident.me)

  if validateIpAddress "$detectedIpAddress"; then
    echo "$detectedIpAddress"

    return
  fi

  echo "ERROR_IP_ADDRESS_NOT_AVAILABLE"
}

if [[ -f "$defaultUrsaConfigPath" ]]; then
  printf "üí© Uh oh! The installer found that a Ursa config directory already exists at %s.\nA backup was created at %s..." "$defaultUrsaConfigPath" "$defaultUrsaConfigBackupPath"

  if ! cp "$defaultUrsaConfigPath" "$defaultUrsaConfigBackupPath"; then
    echo "üëπ Oops! Failed to create config.toml backup..."

    exit 1
  fi

  echo "‚úÖ Done! Backup file was created $defaultUrsaConfigBackupPath"
fi

cat << "URSA_START_SCRIPT"
          _..._
        .'     '.     _
      /    .-""-\   _/ \
    .-|   /:.   |  |   |
    |  \  |:.   /.-'-./
    | .-'-;:__.'    =/
    .'=  *=|URSA _.='
    /   _.  |    ;
    ;-.-'|    \   |
  /   | \    _\  _\
  \__/'._;.  ==' ==\
          \    \   |
          /    /   /
          /-._/-._/
          \   `\  \
            `-._/._/
URSA_START_SCRIPT

echo
echo "‚≠êÔ∏è Ursa, a Decentralized Content Delivery Network (DCDN) ‚≠êÔ∏è"
echo
echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ üåç Website https://fleek.network"
echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ üìö Documentation https://docs.fleek.network"
echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ üíæ Git repository https://github.com/fleek-network/ursa"
echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ ü§ñ Discord https://discord.gg/fleekxyz"
echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ üê§ Twitter https://twitter.com/fleek_net"
echo "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ üé® Ascii art by https://www.asciiart.eu"
echo

printf "ü§ñ Check if operating system is supported\n"
isOSSupported

echo

echo "A domain name is required to secure the communications with SSL/TLS."
echo
echo "Visit your domain name registrar dashboard, create a new domain, and update the A record pointed to the server public IP address."
echo "If you don't have a domain name (DNS, as ENS or similar are not supported), you can get one from a registrar e.g. https://njal.la, https://name.com, etc."
echo
echo "Need help? Read our guide https://docs.fleek.network/guides/Network%20nodes/fleek-network-securing-a-node-with-ssl-tls#domain-name-setup"
echo "Make sure you complete this step before proceeding, as it'll be verified!"
echo

while read -rp "Have you updated the DNS settings A record? (yes/no) " answer; do
  if [[ $answer == [yY] || $answer == [yY][eE][sS] ]]; then
    break;
  fi

  printf "üëπ Oh no! A domain name is required to secure the communications\n"

  exit 1
done

echo

printf -v prompt "ü§ñ What's your domain name address?"
while read -rp "$prompt"$'\n> ' answer; do
  if confirmDomainName "$answer"; then
    selectedDomainName="$answer"
    break
  fi

  printf "üí© The domain name provided is not valid!\n"

  [[ "$answer" =~ http* ]] && echo "üí° Just type the domain name address, there's no need for http:// or https:// e.g. mynode.example.com"
done

echo

detectedIpAddress=$(getIpAddress)

if ! validateIpAddress "$detectedIpAddress"; then
  printf "üëπ Oops! We found the server public IP to be invalid (%s), if you found this to be a bug, help us improve by reporting it in our discord channel üôè\n" "$detectedIpAddress"

  exit 1
fi

echo

printf "The server public IP address the domain is pointing to is required! We found the public IP address for this machine to be %s\n" "$detectedIpAddress"
printf -v prompt "ü§ñ Is the domain name %s pointing to the public IP address %s? (yes/no) " "$selectedDomainName" "$detectedIpAddress"
while read -rp "$prompt"$'\n> ' answer; do
  if [[ $answer == [nN] || $answer == [nN][oO] ]]; then
    printf "üí© Oh no! The %s has to point to the server public IP address %s. Alternatively, you can check our guides and install the Ursa CLI on your own, but is likely that the security of your server will be taken into account by the rewards mechanism. To avoid disappointment follow the recomendations!\n" "$selectedDomainName" "$detectedIpAddress"  

    continue
  fi

  if [[ $answer == [yY] || $answer == [yY][eE][sS] ]]; then
    # Dig is required for the next step
    if ! dpkg -s bind9-dnsutils >/dev/null; then
      echo "üôã‚Äç‚ôÄÔ∏è bind9-dnsutils is required, we'll go ahead and install it"
      printf "ü§ñ Update and upgrade apt-get\n"
      sudo DEBIAN_FRONTEND=noninteractive apt-get update -yq
      sudo DEBIAN_FRONTEND=noninteractive apt-get upgrade -yq

      if ! sudo DEBIAN_FRONTEND=noninteractive apt-get install bind9-dnsutils -y; then
        printf "üëπ Oops! Failed to install dnsutils for some reason...\n"
      fi
    fi

    if ! dig "$selectedDomainName" +nostats +nocomments +nocmd | tr -d '\t' | grep "A$detectedIpAddress" >/dev/null 2>&1 ; then
      printf "üí© Oh no! The %s doesn't seem to point to the IP address %s\n" "$selectedDomainName" "$detectedIpAddress"

      continue
    fi

    selectedIpAddress="$detectedIpAddress"

    break
  fi

  printf "üòÖ Sorry! Try that again...\n"
done

echo

printf "Let's Encrypt provides SSL/TLS Certificates for securing the communications. A valid email address is required by the Let's Encrypt organisation (Fleek Network is not affiliated and does NOT store the email address).\n"
printf -v prompt "What's your email address?"
while read -rp "$prompt"$'\n> ' answer; do
  if confirmEmailAddress "$answer"; then
    selectedEmailAddress="$answer"
    break
  fi

  printf "üí© Oh no! The email address doesn't seem valid, try again...\n"
done

echo

printf "ü§ñ The Ursa source-code is going to be stored in the recommended path %s (otherwise, type \"n\" to modify path)\n" "$defaultUrsaPath"
printf -v prompt "Should we proceed and install to path %s? (yes/no)" "$defaultUrsaPath"
while read -r -p "$prompt"$'\n> ' answer; do
  if [[ "$answer" == [nN] || "$answer" == [nN][oO] ]]; then
    printf -v prompt "\nüôã‚Äç‚ôÄÔ∏è What path should we clone the Ursa source-code to?\n"
    read -r -p "$prompt"$'\n> ' answer

    if [[ -d "$answer" ]]; then
      printf "üëπ Oops! The path %s already exists! This might be annoying but we don't want to mess with your system. So, clear the path and try again...\n" "$answer"

      exit 1
    fi

    if ! mkdir -p "$selectedUrsaPath"; then
      printf "üëπ Oops! Failed to create the path %s\n" "$selectedUrsaPath"

      exit 1
    fi

    selectedUrsaPath="$answer"

    break
  fi

  if [[ "$answer" == [yY] || "$answer" == [yY][eE][sS] ]]; then
    selectedUrsaPath="$defaultUrsaPath"
    
    break
  fi
done

echo

printf "ü§ñ Update and upgrade apt-get\n"
sudo DEBIAN_FRONTEND=noninteractive apt-get update -yq
sudo DEBIAN_FRONTEND=noninteractive apt-get upgrade -yq

echo

if ! hasCommand git; then
  printf "ü§ñ Install Git\n"
  sudo DEBIAN_FRONTEND=noninteractive apt-get install git -yq
fi

echo

printf "ü§ñ Clone the Ursa source-code (git repository) to %s\n" "$selectedUrsaPath"
git clone https://github.com/fleek-network/ursa.git "$selectedUrsaPath"

echo

printf "ü§ñ Change directory to ursa (git repository)\n"
if ! cd "$selectedUrsaPath"; then
  printf "üëπ Oops! Failed to change directory to %s\n" "$selectedUrsaPath"

  exit 1
fi

echo

if ! command -vp "cargo" &> /dev/null && ! command -vp "rustc" &> /dev/null; then
  printf "ü§ñ Install the Rustup tool\n"
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y

  echo

  printf "ü§ñ Reload PATH environments to include Cargo\n"
  source "$HOME/.cargo/env"
  
  echo

  printf "‚úÖ Rust is installed!\n"

  printf "Cargo version is %s\n" "$(cargo --version)"
else
  printf "ü§ñ Update Rustup\n"
  rustup update
fi

echo

printf "ü§ñ Install the build-essentials, libraries and packages, necessary for compiling general software and for our use-case Ursa CLI\n"
sudo DEBIAN_FRONTEND=noninteractive apt-get install build-essential cmake clang pkg-config libssl-dev protobuf-compiler -yq

echo

if ! hasCommand make; then
  printf "ü§ñ Install make\n"
  sudo DEBIAN_FRONTEND=noninteractive apt-get install make -yq
fi

# OBS: sccache takes quite long to install
# after the installation there was no perceived benefit in having it
# sccache requires build-essentials (install after)
## printf "ü§ñ Install Sccache is a ccache-like compiler caching tool\n"
## cargo install sccache

echo

printf "ü§ñ Build and install the Ursa CLI\n"

if ! cargo install --jobs "$vCPUsMinusOne" --locked --path crates/ursa; then
  printf "üëπ Oops! Failed to build and install the Ursa CLI. If you are experiencing issues, help us improve by letting us know in our Discord channel\n"

  exit 1
fi

echo

printf "ü§ñ Symlink the Ursa CLI binary to /usr/bin. By default rustup should've set the .cargo/bin into your system PATH, in any case we'll attempt to symlink to ensure ursa is available globally\n"
if [[ -f "$HOME/.cargo/bin/ursa" ]]; then
  if ! ln -s "$HOME/.cargo/bin/ursa" /usr/bin/ursa; then
    printf "üëπ Oops! Failed to symlink %s to /usr/bin/ursa\n" "$HOME/.cargo/bin/ursa"
    echo
    read -rp "üòÖ After the installation, if ursa cli command is not available globally, then you need to add $HOME/.cargo/bin/ursa to your system PATH or symlink the binary to /usr/bin/ursa, as we've failed to do it. Press ENTER to continue..."
  fi
else
  if ! ln -s "$selectedUrsaPath/target/release/ursa" /usr/bin/ursa; then
    printf "üëπ Oops! Failed to symlink %s to /usr/bin/ursa\n" "$selectedUrsaPath/target/release/ursa"
    echo
    read -rp "üòÖ After the installation, if ursa cli command is not available globally, then you need to add $selectedUrsaPath/target/release/ursa to your system PATH or symlink the binary to /usr/bin/ursa, as we've failed to do it. Press ENTER to continue..."
  fi
fi

echo

printf "üëå Great! You have successfully installed required packages, libraries, have compiled and installed Ursa\n\n"
printf "The Ursa CLI should be available globally, there's a symlink to the /usr/bin/ursa. Which means that from now on you can start a Network Node by typing ursa\n"

echo

printf "üîì Our wizard will now attempt to install additional applications, to help secure the server e.g. Nginx (reverse proxy), secure the communications with SSL/TLS, etc. Be patient, please üôè\n"

echo

if ! hasCommand nginx; then
  selectedNginxSitesAvailablePath="$defaultNginxSitesAvailablePath"
  selectedNginxSitesEnabledPath="$defaultNginxSitesEnabledPath"

  printf "ü§ñ Install Nginx\n"
  sudo DEBIAN_FRONTEND=noninteractive apt install nginx -yq
else
  printf "üí° The install process encountered Nginx already installed\nIt'll assume that the location for sites-available and sites-enabled are the default paths %s and %s\n" "$defaultNginxSitesAvailablePath" "$defaultNginxSitesEnabledPath"
  printf -v prompt "Use the default paths for Nginx sites-available and sites-enabled? (yes/no)"
  while read -rp "$prompt"$'\n> ' answer; do
    if [[ $answer == [yY][eE][sS] || $answer == [yY] ]]; then
      selectedNginxSitesAvailablePath="$defaultNginxSitesAvailablePath"
      selectedNginxSitesEnabledPath="$defaultNginxSitesEnabledPath"

      break;
    fi

    if [[ $answer == [nN][oO] || $answer == [nN] ]]; then
      while read -rp "What's the path for sites-available?" answer; do
        if [[ ! -d "$answer" ]]; then
          printf "üí© Uh-oh! The directory (%s) was not found. You might want to create it first, try again...\n" "$answer"

          continue;
        fi

        selectedNginxSitesAvailablePath="$answer"
        break;
      done

      while read -rp "What's the path for sites-enabled?" answer; do
        if [[ ! -d "$answer" ]]; then
          printf "üí© Uh-oh! The directory (%s) was not found. You might want to create it first, try again...\n" "$answer"

          continue;
        fi

        selectedNginxSitesEnabledPath="$answer"
        break;
      done
    fi
  done
fi

echo

printf "ü§ñ Remove Nginx default config\n"
rm -f /etc/nginx/sites-available/default
rm -f /etc/nginx/sites-enabled/default

echo

if [[ -f "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpConfFilename" ]]; then
  rm "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpConfFilename"
fi

touch "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpConfFilename"

if [[ -f "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpsConfFilename" ]]; then
  rm "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpsConfFilename"
fi

touch "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpsConfFilename"

printf "ü§ñ Create the Nginx directories for ACME Challenge\n"
mkdir -p "/var/www/$selectedDomainName/.well-known/acme-challenge"

echo

printf "ü§ñ Create ACME Challenge directory health check placeholder\n"
if [[ -f "/var/www/$selectedDomainName/.well-known/acme-challenge/healthcheck" ]]; then
  rm "/var/www/$selectedDomainName/.well-known/acme-challenge/healthcheck"
fi
echo "${defaultACMEChallengeMsgPlaceholder/_domain_/$selectedDomainName}" >> "/var/www/$selectedDomainName/.well-known/acme-challenge/healthcheck"

echo

printf "ü§ñ Create the HTTP Nginx config file for Ursa\n"
echo "
proxy_cache_path /cache keys_zone=nodecache:100m levels=1:2 inactive=31536000s max_size=10g use_temp_path=off;

server {
  listen 80;
  listen [::]:80;
  server_name $selectedDomainName;

  location ^~ /.well-known/acme-challenge/ {
    # No auth required
    allow all;

    # Safe type
    default_type \"text/plain\";

    # Path given to certbot as -w param of the webroot plugin
    root         /var/www/$selectedDomainName;
    break;
  }

  # Hides /acme-challenge subdir returning 404 on all requests
  # Keep the ending slash
  location = /.well-known/acme-challenge/ {
    return 404;
  }

  location /stub_status {
    stub_status;
  }

  proxy_redirect          off;
  client_max_body_size    10m;
  client_body_buffer_size 128k;
  proxy_connect_timeout   90;
  proxy_send_timeout      90;
  proxy_read_timeout      90;
  proxy_buffers           32 128k;

  location / {
    add_header content-type  application/vnd.ipld.raw;
    add_header content-type  application/vnd.ipld.car;
    add_header content-type  application/octet-stream;
    add_header cache-control public,max-age=31536000,immutable;

    proxy_cache nodecache;
    proxy_cache_valid 200 31536000s;
    add_header X-Proxy-Cache \$upstream_cache_status;
    proxy_cache_methods GET HEAD POST;
    proxy_cache_key \"\$request_uri|\$request_body\";
    client_max_body_size 1G;

    proxy_pass http://localhost:4069;
  }
  
  location /metrics {
    proxy_pass http://localhost:4069;
  }
}
" > "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpConfFilename"

printf "ü§ñ Create the HTTPS Nginx config file for Ursa\n"
echo "
server {
  listen 443 ssl http2;
  listen [::]:443 ssl http2;
  server_name $selectedDomainName;

  server_tokens off;

  # SSL code
  ssl_certificate /etc/letsencrypt/live/$selectedDomainName/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/$selectedDomainName/privkey.pem;

  include $defaultLetsEncryptOptionsSSLNginxConf;
  ssl_dhparam $defaultLetsEncryptSSLDHParams;

  location /stub_status {
    stub_status;
  }

  location / {
    add_header content-type  application/vnd.ipld.raw;
    add_header content-type  application/vnd.ipld.car;
    add_header content-type  application/octet-stream;
    add_header cache-control public,max-age=31536000,immutable;

    proxy_cache nodecache;
    proxy_cache_valid 200 31536000s;
    add_header X-Proxy-Cache \$upstream_cache_status;
    proxy_cache_methods GET HEAD POST;
    proxy_cache_key \"\$request_uri|\$request_body\";
    client_max_body_size 1G;

    proxy_pass http://localhost:4069;
  }
  
  location /metrics {
    proxy_pass http://localhost:4069;
  }
}
" > "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpsConfFilename"

printf "ü§ñ Enable Nginx HTTP config for now, HTTPS will be enabled after the SSL/TLS setup from Let's Encrypt\n"
if [[ -f "$selectedNginxSitesEnabledPath/$defaultUrsaNginxHttpConfFilename" ]]; then
  rm "$selectedNginxSitesEnabledPath/$defaultUrsaNginxHttpConfFilename"
fi
sudo ln -s "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpConfFilename" "$selectedNginxSitesEnabledPath/$defaultUrsaNginxHttpConfFilename"

echo

if hasCommand ufw && ufw status | grep -q 'Status: active'; then
  printf "üí° Detected that ufw is active\n"
  printf "ü§ñ HTTP and HTTPS will be set as allowed via ufw\n"

  if ! sudo ufw allow 'Nginx HTTP'; then
    printf "üí© Uh-oh! Failed to allow Nginx HTTP for some reason...\n"

    read -rp "üôÑ Make sure your firewall setup is correct, as the installer is likely to fail. Press ENTER to continue..."
  fi
  
  if ! sudo ufw allow 'Nginx HTTPS'; then
    printf "üí© Uh-oh! Failed to allow Nginx HTTPS for some reason...\n"

    read -rp "üôÑ Make sure your firewall setup is correct, as the installer is likely to fail. Press ENTER to continue..."
  fi
else
  printf -v prompt "üöì Warning! Make sure you don't have the ports %s blocked by a firewall. The installer will fail if you don't have the required ports open! Press ENTER to continue..." "${requiredPorts[*]}"
  read -rp "$prompt"
fi

echo

printf "ü§ñ Start Nginx\n"
if systemctl -q is-active nginx; then
  if ! sudo systemctl restart nginx; then
    printf "üí© Uh-oh! Failed to restart Nginx for some reason...\n"

    exit 1
  fi
else
  if ! sudo systemctl start nginx; then
    printf "üí© Uh-oh! Failed to start Nginx for some reason...\n"

    exit 1
  fi
fi

echo

printf "üöë ACME Challenge health-check\n"
if ! curl -s "http://$selectedDomainName/.well-known/acme-challenge/healthcheck" | grep -q "${defaultACMEChallengeMsgPlaceholder/_domain_/$selectedDomainName}"; then
  printf "üí© Uh-oh! The ACME Challenge health-check failed for some reason, make sure you don't have any firewall or apps blocking ports %s...\n" "${requiredPorts[*]}"
fi

initCertbot "$selectedDomainName" "$selectedEmailAddress"

echo

printf "ü§ñ Enable Nginx HTTPS\n"
if [[ -f "$selectedNginxSitesEnabledPath/$defaultUrsaNginxHttpsConfFilename" ]]; then
  rm "$selectedNginxSitesEnabledPath/$defaultUrsaNginxHttpsConfFilename"
fi
sudo ln -s "$selectedNginxSitesAvailablePath/$defaultUrsaNginxHttpsConfFilename" "$selectedNginxSitesEnabledPath/$defaultUrsaNginxHttpsConfFilename"

if [[ ! -f "$defaultLetsEncryptOptionsSSLNginxConf" ]]; then
  printf "üßê Hmm, missing file! Will create Lets Encrypt options SSL Nginx configuration\n"
  curl -s https://raw.githubusercontent.com/certbot/certbot/master/certbot-nginx/certbot_nginx/_internal/tls_configs/options-ssl-nginx.conf > "$defaultLetsEncryptOptionsSSLNginxConf"
fi

if [[ ! -f "$defaultLetsEncryptSSLDHParams" ]]; then
  printf "üßê Hmm, missing file! Will create Lets Encrypt SSLDHParams\n"
  curl -s https://raw.githubusercontent.com/certbot/certbot/master/certbot/certbot/ssl-dhparams.pem > "$defaultLetsEncryptSSLDHParams"
fi

echo

printf "ü§ñ Nginx reload\n"
service nginx reload

# Verify the syntax of your configuration edits
if sudo nginx -t; then
  sudo systemctl restart nginx
else
  printf "üëπ Oh no! The Nginx configuration syntax is invalid, looks like a bug. Help us improve and report in our discord channel, please!\n"

  exit 1
fi

if ! sudo certbot renew --dry-run; then
  printf "üòì This is very unfortunate! The certbot renewal verification process failed for %s\nThe installer will continue, but is likely that when the SSL/TLS Certificate expires, the scheduled renewal will fail" "$selectedDomainName"

  sleep 8
fi

printf "ü§ñ Set Ursa server IP Address in the configuration file\n"
if [[ -f "$defaultUrsaConfigPath" ]]; then
  echo "ü§ñ The installer found that a Ursa config directory already exists at $defaultUrsaConfigPath. The install wizard will update the addresses in the config.toml with your server IP addresss."

  if ! sed -i "s|addresses =.*|addresses = [\"/ip4/$selectedIpAddress/tcp/80\"]|" "$defaultUrsaConfigPath"; then
    printf "üëπ Oh no! Failed to update the addresses with your server IP adress (%s) in the config.toml\n" "$selectedIpAddress"

    exit 1
  fi
else
  if ! mkdir -p "$defaultUrsaBasePath"; then
    printf "üëπ Oh no! Failed to create the directory %s\n" "$defaultUrsaBasePath"

    exit 1
  fi

  if ! touch "$defaultUrsaConfigPath"; then
    printf "üëπ Oh no! Failed to create the config.toml at %s\n" "$defaultUrsaBasePath"

    exit 1
  fi

  if ! echo "[server_config]" >> "$defaultUrsaConfigPath" || ! echo "addresses = [\"/ip4/$selectedIpAddress/tcp/80\"]" >> "$defaultUrsaConfigPath"; then
    printf "üëπ Oh no! Failed to populate the config file %s\n" "$defaultUrsaConfigPath"

    exit 1
  fi
fi

while read -rp "ü§ó Would you like to start the Network Node now? (yes/no) " answer; do
  if [[ $answer == [yY] || $answer == [yY][eE][sS] ]]; then
    break;
  elif [[ $answer == [nN] || $answer == [nN][oO] ]]; then
    printf "ü§ó All done!\n"
    exit 1
  fi
done

echo
# The extra-whitespace between emoji and text is intentional
# used for alignment
echo "‚ö†Ô∏è  Be aware that the Network Node outputs a lot of messages, the messages are quite verbose and you shouldn't worry about it! To keep it simple and not confusing, we'll keep the output of the Node in $defaultUrsaLogPath."
echo
echo "The log messages have many types INFO, DEBUG, WARNINGS, ERRORS, etc. Be patient! To understand what they mean, read our Node Health-check guide https://docs.fleek.network/guides/Network%20nodes/fleek-network-node-health-check-guide"
echo

read -rp "Press ENTER to continue..."
echo

printf "ü§ñ Create a Systemd Ursa service\n"
printf "ü§ñ Create the Ursa log directory %s\n" "$defaultUrsaLogPath"
if ! mkdir -p "$defaultUrsaLogPath"; then
  printf "üí© Uh-oh! Failed to create the Ursa system log dir %s for some reason...\n" "$defaultUrsaLogPath"
fi

printf "ü§ñ Declare the service and store in the system path\n"
cat << URSA_SERVICE > "$defaultUrsaSystemdServicePath"
[Unit]
Description=Ursa, a Decentralized Content Delivery Network (DCDN)

[Service]
Type=simple
MemoryMax=8G
RestartSec=15s
Restart=always
ExecStart=/usr/bin/ursa
StandardOutput=append:$defaultUrsaOutputLogAbsPath
StandardError=append:$defaultUrsaDiagnosticLogAbsPath

[Install]
WantedBy=multi-user.target
URSA_SERVICE

printf "ü§ñ Set service file permissions\n"
sudo chmod 644 "$defaultUrsaSystemdServicePath"

printf "ü§ñ System control daemon reload\n"
sudo systemctl daemon-reload

printf "ü§ñ Start the Ursa service\n"
sudo systemctl start "$defaultUrsaSystemdServiceName"

printf "ü§ñ Enable Ursa service on startup when the system boots\n"
sudo systemctl enable "$defaultUrsaSystemdServiceName"

printf "ü§ñ Ursa service availability check\n"
pingAttempts=0
while ! curl -s localhost:4069/ping | grep -q pong; do
  if [[ "$pingAttempts" -gt 10 ]]; then
    printf "üëπ Oh no! Failed to health-check the domain %s\n" "$selectedDomainName"

    break;
  fi

  printf "ü§ñ Awaiting Ursa on port 4069...\n"
  sleep 1

  ((pingAttempts++))
done

printf "üöë Health check %s via HTTPS /ping endpoint\n" "$selectedDomainName"
if ! curl -s https://$selectedDomainName/ping | grep -q pong; then
  printf "üí© Uh-oh! Failed to health-check the domain %s\n" "$selectedDomainName"
  echo
  echo "Learn how to do a Health Check by following the guide https://docs.fleek.network/guides/Network%20nodes/fleek-network-node-health-check-guide"
else
  printf "‚úÖ Health checked!\n"
fi

echo
echo "üåà The Fleek Network Node is running!"
echo
echo "You can watch the Node output by running the command:"
echo "tail -f $defaultUrsaOutputLogAbsPath"
echo
echo "For diagnostics run the command:"
echo "tail -f $defaultUrsaDiagnosticLogAbsPath"
echo
echo "Launch or stop the Network Node by running:"
echo "sudo systemctl stop ursa"
echo "sudo systemctl restart ursa"
echo
echo "Check the status of the service:"
echo "sudo systemctl status ursa"
echo
echo "Learn more by checking our guides at https://docs.fleek.network"
echo "‚ú® That's all!"
echo
